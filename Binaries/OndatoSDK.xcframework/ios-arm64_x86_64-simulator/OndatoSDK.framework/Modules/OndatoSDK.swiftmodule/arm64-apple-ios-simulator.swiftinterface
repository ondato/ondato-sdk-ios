// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0 effective-5.10 (swiftlang-6.0.0.9.10 clang-1600.0.26.2)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name OndatoSDK
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
import AVKit
import CoreGraphics
import CoreImage
import CoreLocation
import CoreNFC
import CoreServices
import CoreText
import Darwin
import DeveloperToolsSupport
import Dispatch
import FaceTecSDK
import Foundation
import ImageIO
import MobileCoreServices
@_exported import OndatoSDK
import Photos
import QuartzCore
import Swift
import SwiftUI
import UIKit
import Vision
import WebKit
import _Concurrency
import _CoreNFC_UIKit
import _StringProcessing
import _SwiftConcurrencyShims
@_hasMissingDesignatedInitializers @objc(OndatoServiceError) public class OndatoServiceError : ObjectiveC.NSObject {
  @objc(OndatoServiceErrorType) public enum OndatoServiceErrorType : Swift.Int {
    case cancelled
    case consentDenied
    case faceDataNotPresent
    case invalidServerResponse
    case invalidCredentials
    case recorderPermissions
    case recorderStartError
    case recorderEndError
    case verificationFailed
    case nfcNotSupported
    case missingModule
    case accessToken
    case idvConfig
    case idvSetup
    case facetecSdk
    case faceSetup
    case facetecLicense
    case kycCompleted
    case kycConfig
    case kycId
    case kycSetup
    case mrzScanner
    case personalCodeUpload
    case recordingUpload
    case restartFailed
    case verificationFailedNoStatus
    case verificationStatusFailed
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  final public let type: OndatoSDK.OndatoServiceError.OndatoServiceErrorType
  final public let error: Swift.String?
  final public let message: Swift.String?
  @objc deinit
}
extension OndatoSDK.Ondato {
  public enum ServiceError : Swift.Error {
    case missingModule(Swift.String)
  }
}
@objc(OndatoLocalizationBundle) public class OndatoLocalizationBundle : ObjectiveC.NSObject {
  @objc public static func bundle(with bundle: Foundation.Bundle, tableName: Swift.String) -> OndatoSDK.OndatoLocalizationBundle
  @objc public init(bundle: Foundation.Bundle, tableName: Swift.String)
  @objc deinit
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency public init(compatibleAnimation: OndatoSDK.CompatibleAnimation)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleAnimation: OndatoSDK.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public func play()
  @objc @_Concurrency.MainActor @preconcurrency final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func stop()
  @objc @_Concurrency.MainActor @preconcurrency final public func pause()
  @objc @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @objc @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: OndatoSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor @preconcurrency final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: OndatoSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func getColorValue(for keypath: OndatoSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: OndatoSDK.AnimationSubview, forLayerAt keypath: OndatoSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: OndatoSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: OndatoSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
public protocol AnimationTextProvider : AnyObject {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
final public class DictionaryTextProvider : OndatoSDK.AnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
final public class DefaultTextProvider : OndatoSDK.AnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension OndatoSDK.Animation {
  public typealias DownloadClosure = (OndatoSDK.Animation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any OndatoSDK.AnimationCacheProvider)? = nil) -> OndatoSDK.Animation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any OndatoSDK.AnimationCacheProvider)? = nil) -> OndatoSDK.Animation?
  public static func loadedFrom(url: Foundation.URL, closure: @escaping OndatoSDK.Animation.DownloadClosure, animationCache: (any OndatoSDK.AnimationCacheProvider)?)
  final public func progressTime(forMarker named: Swift.String) -> OndatoSDK.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> OndatoSDK.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: OndatoSDK.AnimationFrameTime) -> OndatoSDK.AnimationProgressTime
  final public func frameTime(forProgress progressTime: OndatoSDK.AnimationProgressTime) -> OndatoSDK.AnimationFrameTime
  final public func time(forFrame frameTime: OndatoSDK.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> OndatoSDK.AnimationFrameTime
}
@objc @_Concurrency.MainActor @preconcurrency open class AnimatedControl : UIKit.UIControl {
  @_Concurrency.MainActor @preconcurrency public init(animation: OndatoSDK.Animation)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency final public let animationView: OndatoSDK.AnimationView
  @_Concurrency.MainActor @preconcurrency public var animation: OndatoSDK.Animation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setLayer(named: Swift.String, forState: UIKit.UIControl.State)
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any OndatoSDK.AnyValueProvider, keypath: OndatoSDK.AnimationKeypath)
  @objc deinit
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension QuartzCore.CALayer {
  public func logLayerTree(withIndent: Swift.Int = 0)
}
public class Asset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.InfallibleType {
  public var values: _Concurrency.AsyncStream<Self.Element> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public static func zip<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : OndatoSDK.ObservableType
  public static func zip<Collection>(_ collection: Collection) -> OndatoSDK.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public func withLatestFrom<Source, ResultType>(_ second: Source, resultSelector: @escaping (Self.Element, Source.Element) throws -> ResultType) -> OndatoSDK.Observable<ResultType> where Source : OndatoSDK.ObservableConvertibleType
  public func withLatestFrom<Source>(_ second: Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBar {
  public var willBeginCustomizing: OndatoSDK.ControlEvent<[UIKit.UITabBarItem]> {
    get
  }
  public var didBeginCustomizing: OndatoSDK.ControlEvent<[UIKit.UITabBarItem]> {
    get
  }
  public var willEndCustomizing: OndatoSDK.ControlEvent<([UIKit.UITabBarItem], Swift.Bool)> {
    get
  }
  public var didEndCustomizing: OndatoSDK.ControlEvent<([UIKit.UITabBarItem], Swift.Bool)> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBar {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UITabBar, any UIKit.UITabBarDelegate> {
    get
  }
  public var didSelectItem: OndatoSDK.ControlEvent<UIKit.UITabBarItem> {
    get
  }
}
public struct Disposables {
}
public protocol KVORepresentable {
  associatedtype KVOType
  init?(KVOValue: Self.KVOType)
}
public struct KeyValueObservingOptions : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let initial: OndatoSDK.KeyValueObservingOptions
  public static let new: OndatoSDK.KeyValueObservingOptions
  public typealias ArrayLiteralElement = OndatoSDK.KeyValueObservingOptions
  public typealias Element = OndatoSDK.KeyValueObservingOptions
  public typealias RawValue = Swift.UInt
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> OndatoSDK.Observable<Element?> where Element : OndatoSDK.KVORepresentable
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element?> where Element : OndatoSDK.KVORepresentable
}
extension UIKit.UINavigationController : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UINavigationControllerDelegate
}
open class RxNavigationControllerDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UINavigationController, any UIKit.UINavigationControllerDelegate>, OndatoSDK.DelegateProxyType {
  weak public var navigationController: UIKit.UINavigationController? {
    get
  }
  public init(navigationController: OndatoSDK.RxNavigationControllerDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxNavigationControllerDelegateProxy : UIKit.UINavigationControllerDelegate {
}
extension OndatoSDK.ObservableType {
  public func scan<A>(into seed: A, accumulator: @escaping (inout A, Self.Element) throws -> Swift.Void) -> OndatoSDK.Observable<A>
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> OndatoSDK.Observable<A>
}
extension OndatoSDK.ObservableType {
  public func materialize() -> OndatoSDK.Observable<OndatoSDK.Event<Self.Element>>
}
open class VirtualTimeScheduler<Converter> : OndatoSDK.SchedulerType where Converter : OndatoSDK.VirtualTimeConverterType {
  public typealias VirtualTime = Converter.VirtualTimeUnit
  public typealias VirtualTimeInterval = Converter.VirtualTimeIntervalUnit
  public var now: OndatoSDK.RxTime {
    get
  }
  public var clock: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime {
    get
  }
  public init(initialClock: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime, converter: Converter)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func scheduleRelativeVirtual<StateType>(_ state: StateType, dueTime: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func scheduleAbsoluteVirtual<StateType>(_ state: StateType, time: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  open func adjustScheduledTime(_ time: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime) -> OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime
  public func start()
  public func advanceTo(_ virtualTime: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime)
  public func sleep(_ virtualInterval: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTimeInterval)
  public func stop()
  @objc deinit
}
extension OndatoSDK.VirtualTimeScheduler : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@frozen public enum Event<Element> {
  case next(Element)
  case error(any Swift.Error)
  case completed
}
extension OndatoSDK.Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.Event {
  public var isStopEvent: Swift.Bool {
    get
  }
  public var element: Element? {
    get
  }
  public var error: (any Swift.Error)? {
    get
  }
  public var isCompleted: Swift.Bool {
    get
  }
}
extension OndatoSDK.Event {
  public func map<Result>(_ transform: (Element) throws -> Result) -> OndatoSDK.Event<Result>
}
public protocol EventConvertible {
  associatedtype Element
  var event: OndatoSDK.Event<Self.Element> { get }
}
extension OndatoSDK.Event : OndatoSDK.EventConvertible {
  public var event: OndatoSDK.Event<Element> {
    get
  }
}
public protocol RxTableViewDataSourceType {
  associatedtype Element
  func tableView(_ tableView: UIKit.UITableView, observedEvent: OndatoSDK.Event<Self.Element>)
}
extension UIKit.UITableView : OndatoSDK.HasDataSource {
  public typealias DataSource = UIKit.UITableViewDataSource
}
open class RxTableViewDataSourceProxy : OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSource>, OndatoSDK.DelegateProxyType {
  weak public var tableView: UIKit.UITableView? {
    get
  }
  public init(tableView: UIKit.UITableView)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UITableViewDataSource)?, retainDelegate: Swift.Bool)
  @objc deinit
}
extension OndatoSDK.RxTableViewDataSourceProxy : UIKit.UITableViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
}
extension OndatoSDK.Reactive where Base : Foundation.NotificationCenter {
  public func notification(_ name: Foundation.Notification.Name?, object: Swift.AnyObject? = nil) -> OndatoSDK.Observable<Foundation.Notification>
}
extension OndatoSDK.ObservableType {
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
}
extension OndatoSDK.ObservableType {
  public func window(timeSpan: OndatoSDK.RxTimeInterval, count: Swift.Int, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<OndatoSDK.Observable<Self.Element>>
}
extension OndatoSDK.ObservableType {
  public static func amb<Sequence>(_ sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func amb<O2>(_ right: O2) -> OndatoSDK.Observable<Self.Element> where O2 : OndatoSDK.ObservableType, Self.Element == O2.Element
}
extension OndatoSDK.ObservableType {
  public func sample<Source>(_ sampler: Source, defaultValue: Self.Element? = nil) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
}
public struct TextInput<Base> where Base : UIKit.UITextInput {
  public let base: Base
  public let text: OndatoSDK.ControlProperty<Swift.String?>
  public init(base: Base, text: OndatoSDK.ControlProperty<Swift.String?>)
}
extension OndatoSDK.Reactive where Base : UIKit.UITextField {
  public var textInput: OndatoSDK.TextInput<Base> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UITextView {
  public var textInput: OndatoSDK.TextInput<Base> {
    get
  }
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2>(_ source1: I1, _ source2: I2, resultSelector: @escaping (I1.Element, I2.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3>(_ source1: I1, _ source2: I2, _ source3: I3, resultSelector: @escaping (I1.Element, I2.Element, I3.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5, I6>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, _ source6: I6, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element, I6.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType, I6 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5, I6, I7>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, _ source6: I6, _ source7: I7, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element, I6.Element, I7.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType, I6 : OndatoSDK.InfallibleType, I7 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5, I6, I7, I8>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, _ source6: I6, _ source7: I7, _ source8: I8, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element, I6.Element, I7.Element, I8.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType, I6 : OndatoSDK.InfallibleType, I7 : OndatoSDK.InfallibleType, I8 : OndatoSDK.InfallibleType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.Observable<(O1.Element, O2.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
public typealias Driver<Element> = OndatoSDK.SharedSequence<OndatoSDK.DriverSharingStrategy, Element>
public struct DriverSharingStrategy : OndatoSDK.SharingStrategyProtocol {
  public static var scheduler: any OndatoSDK.SchedulerType {
    get
  }
  public static func share<Element>(_ source: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.DriverSharingStrategy {
  public func asDriver() -> OndatoSDK.Driver<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func enumerated() -> OndatoSDK.Observable<(index: Swift.Int, element: Self.Element)>
}
extension OndatoSDK.ObservableType {
  public func ifEmpty(default: Self.Element) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableConvertibleType {
  public func asSignal(onErrorJustReturn: Self.Element) -> OndatoSDK.Signal<Self.Element>
  public func asSignal(onErrorSignalWith: OndatoSDK.Signal<Self.Element>) -> OndatoSDK.Signal<Self.Element>
  public func asSignal(onErrorRecover: @escaping (_ error: any Swift.Error) -> OndatoSDK.Signal<Self.Element>) -> OndatoSDK.Signal<Self.Element>
}
@_hasMissingDesignatedInitializers final public class ConcurrentMainScheduler : OndatoSDK.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  final public var now: Foundation.Date {
    get
  }
  public static let instance: OndatoSDK.ConcurrentMainScheduler
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
  @objc deinit
}
extension OndatoSDK.ControlEvent {
  public func asSignal() -> OndatoSDK.Signal<OndatoSDK.ControlEvent<PropertyType>.Element>
}
public enum RxError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case disposed(object: Swift.AnyObject)
  case overflow
  case argumentOutOfRange
  case noElements
  case moreThanOneElement
  case timeout
}
extension OndatoSDK.RxError {
  public var debugDescription: Swift.String {
    get
  }
}
public struct AnyObserver<Element> : OndatoSDK.ObserverType {
  public typealias EventHandler = (OndatoSDK.Event<Element>) -> Swift.Void
  public init(eventHandler: @escaping OndatoSDK.AnyObserver<Element>.EventHandler)
  public init<Observer>(_ observer: Observer) where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  public func on(_ event: OndatoSDK.Event<Element>)
  public func asObserver() -> OndatoSDK.AnyObserver<Element>
}
extension OndatoSDK.ObserverType {
  public func asObserver() -> OndatoSDK.AnyObserver<Self.Element>
  public func mapObserver<Result>(_ transform: @escaping (Result) throws -> Self.Element) -> OndatoSDK.AnyObserver<Result>
}
public protocol RxPickerViewDataSourceType {
  associatedtype Element
  func pickerView(_ pickerView: UIKit.UIPickerView, observedEvent: OndatoSDK.Event<Self.Element>)
}
extension OndatoSDK.ObservableType {
  public func observe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "observe(on:)")
  public func observeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UISearchController {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UISearchController, any UIKit.UISearchControllerDelegate> {
    get
  }
  public var didDismiss: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var didPresent: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var present: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var willDismiss: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var willPresent: OndatoSDK.Observable<Swift.Void> {
    get
  }
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.DriverSharingStrategy {
  public func drive<Observer>(_ observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func drive<Observer>(_ observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func drive(_ relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func drive(_ relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func drive(_ relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func drive(_ relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func drive<Result>(_ transformation: (OndatoSDK.Observable<Self.Element>) -> Result) -> Result
  public func drive<R1, R2>(_ with: (OndatoSDK.Observable<Self.Element>) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func drive<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func drive(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func drive() -> any OndatoSDK.Disposable
}
@_hasMissingDesignatedInitializers final public class MainScheduler : OndatoSDK.SerialDispatchQueueScheduler {
  public init()
  public static let instance: OndatoSDK.MainScheduler
  public static let asyncInstance: OndatoSDK.SerialDispatchQueueScheduler
  public static func ensureExecutingOnScheduler(errorMessage: Swift.String? = nil)
  public static func ensureRunningOnMainThread(errorMessage: Swift.String? = nil)
  @objc deinit
}
@available(iOS 8.0, macOS 10.10, macOSApplicationExtension 10.10, *)
extension OndatoSDK.Reactive where Base : WebKit.WKWebView {
  public var navigationDelegate: OndatoSDK.DelegateProxy<WebKit.WKWebView, any WebKit.WKNavigationDelegate> {
    get
  }
  public var didCommit: OndatoSDK.Observable<WebKit.WKNavigation> {
    get
  }
  public var didStartLoad: OndatoSDK.Observable<WebKit.WKNavigation> {
    get
  }
  public var didFinishLoad: OndatoSDK.Observable<WebKit.WKNavigation> {
    get
  }
  public var didFailLoad: OndatoSDK.Observable<(WebKit.WKNavigation, any Swift.Error)> {
    get
  }
}
extension OndatoSDK.ObservableType where Self.Element == Foundation.Data {
  public func decode<Item, Decoder>(type: Item.Type, decoder: Decoder) -> OndatoSDK.Observable<Item> where Item : Swift.Decodable, Decoder : OndatoSDK.DataDecoder
}
public protocol DataDecoder {
  func decode<Item>(_ type: Item.Type, from data: Foundation.Data) throws -> Item where Item : Swift.Decodable
}
extension Foundation.JSONDecoder : OndatoSDK.DataDecoder {
}
extension Foundation.PropertyListDecoder : OndatoSDK.DataDecoder {
}
extension UIKit.UISearchBar : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UISearchBarDelegate
}
open class RxSearchBarDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UISearchBar, any UIKit.UISearchBarDelegate>, OndatoSDK.DelegateProxyType {
  weak public var searchBar: UIKit.UISearchBar? {
    get
  }
  public init(searchBar: OndatoSDK.RxSearchBarDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxSearchBarDelegateProxy : UIKit.UISearchBarDelegate {
}
extension OndatoSDK.ObservableType {
  public func single() -> OndatoSDK.Observable<Self.Element>
  public func single(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
public enum SingleTrait {
}
public typealias Single<Element> = OndatoSDK.PrimitiveSequence<OndatoSDK.SingleTrait, Element>
public typealias SingleEvent<Element> = Swift.Result<Element, any Swift.Error>
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public typealias SingleObserver = (OndatoSDK.SingleEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.SingleObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.Single<Self.Element>
  public func subscribe(_ observer: @escaping (OndatoSDK.SingleEvent<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
  @available(*, deprecated, renamed: "subscribe(onSuccess:onFailure:onDisposed:)")
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: @escaping ((any Swift.Error) -> Swift.Void), onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onSuccess: ((Object, Self.Element) -> Swift.Void)? = nil, onFailure: ((Object, any Swift.Error) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onFailure: ((any Swift.Error) -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func just(_ element: Self.Element) -> OndatoSDK.Single<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Single<Self.Element>
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Single<Self.Element>
  public static func never() -> OndatoSDK.Single<Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public func `do`(onSuccess: ((Self.Element) throws -> Swift.Void)? = nil, afterSuccess: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Single<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> OndatoSDK.Single<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> OndatoSDK.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Single<Result>) -> OndatoSDK.Single<Result>
  public func flatMapMaybe<Result>(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Maybe<Result>) -> OndatoSDK.Maybe<Result>
  public func flatMapCompletable(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Completable) -> OndatoSDK.Completable
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Self.Element]) throws -> Result) -> OndatoSDK.PrimitiveSequence<Self.Trait, Result> where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.SingleTrait, Self.Element>
  public static func zip<Collection>(_ collection: Collection) -> OndatoSDK.PrimitiveSequence<Self.Trait, [Self.Element]> where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.SingleTrait, Self.Element>
  public func catchAndReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  @available(*, deprecated, renamed: "catchAndReturn(_:)")
  public func catchErrorJustReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  public func asMaybe() -> OndatoSDK.Maybe<Self.Element>
  public func asCompletable() -> OndatoSDK.Completable
}
public protocol ObservableConvertibleType {
  associatedtype Element
  func asObservable() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UITextView {
  public var text: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var attributedText: OndatoSDK.ControlProperty<Foundation.NSAttributedString?> {
    get
  }
  public var didBeginEditing: OndatoSDK.ControlEvent<()> {
    get
  }
  public var didEndEditing: OndatoSDK.ControlEvent<()> {
    get
  }
  public var didChange: OndatoSDK.ControlEvent<()> {
    get
  }
  public var didChangeSelection: OndatoSDK.ControlEvent<()> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func takeLast(_ count: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Disposables {
  public static func create(with dispose: @escaping () -> Swift.Void) -> any OndatoSDK.Cancelable
}
extension OndatoSDK.Reactive where Base : UIKit.UIControl {
  public func controlEvent(_ controlEvents: UIKit.UIControl.Event) -> OndatoSDK.ControlEvent<()>
  public func controlProperty<T>(editingEvents: UIKit.UIControl.Event, getter: @escaping (Base) -> T, setter: @escaping (Base, T) -> Swift.Void) -> OndatoSDK.ControlProperty<T>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.SignalSharingStrategy {
  public func emit<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func emit<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func emit(to relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.PublishRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.PublishRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func emit<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func emit(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func emit() -> any OndatoSDK.Disposable
}
public enum RxCocoaError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case invalidOperation(object: Any)
  case itemsNotYetBound(object: Any)
  case invalidPropertyName(object: Any, propertyName: Swift.String)
  case invalidObjectOnKeyPath(object: Any, sourceObject: Swift.AnyObject, propertyName: Swift.String)
  case errorDuringSwizzling
  case castingError(object: Any, targetType: any Any.Type)
}
extension OndatoSDK.RxCocoaError {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.Observable<(O1.Element, O2.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
extension UIKit.UISearchController : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UISearchControllerDelegate
}
open class RxSearchControllerDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UISearchController, any UIKit.UISearchControllerDelegate>, OndatoSDK.DelegateProxyType {
  weak public var searchController: UIKit.UISearchController? {
    get
  }
  public init(searchController: UIKit.UISearchController)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxSearchControllerDelegateProxy : UIKit.UISearchControllerDelegate {
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBarController {
  public var willBeginCustomizing: OndatoSDK.ControlEvent<[UIKit.UIViewController]> {
    get
  }
  public var willEndCustomizing: OndatoSDK.ControlEvent<(viewControllers: [UIKit.UIViewController], changed: Swift.Bool)> {
    get
  }
  public var didEndCustomizing: OndatoSDK.ControlEvent<(viewControllers: [UIKit.UIViewController], changed: Swift.Bool)> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBarController {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UITabBarController, any UIKit.UITabBarControllerDelegate> {
    get
  }
  public var didSelect: OndatoSDK.ControlEvent<UIKit.UIViewController> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func timeout(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
  public func timeout<Source>(_ dueTime: OndatoSDK.RxTimeInterval, other: Source, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableConvertibleType, Self.Element == Source.Element
}
extension OndatoSDK.ObservableType {
  public func asSingle() -> OndatoSDK.Single<Self.Element>
  public func first() -> OndatoSDK.Single<Self.Element?>
  public func asMaybe() -> OndatoSDK.Maybe<Self.Element>
}
extension OndatoSDK.ObservableType where Self.Element == Swift.Never {
  public func asCompletable() -> OndatoSDK.Completable
}
@_hasMissingDesignatedInitializers final public class BehaviorSubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.ObserverType, OndatoSDK.Cancelable {
  public typealias SubjectObserverType = OndatoSDK.BehaviorSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(value: Element)
  final public func value() throws -> Element
  final public func on(_ event: OndatoSDK.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObserver() -> OndatoSDK.BehaviorSubject<Element>
  final public func dispose()
  public typealias Observer = OndatoSDK.BehaviorSubject<Element>
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func create(_ subscribe: @escaping (OndatoSDK.AnyObserver<Self.Element>) -> any OndatoSDK.Disposable) -> OndatoSDK.Observable<Self.Element>
}
@available(iOS 8.0, macOS 10.10, macOSApplicationExtension 10.10, *)
open class RxWKNavigationDelegateProxy : OndatoSDK.DelegateProxy<WebKit.WKWebView, any WebKit.WKNavigationDelegate>, OndatoSDK.DelegateProxyType {
  weak public var webView: WebKit.WKWebView? {
    get
  }
  public init(webView: OndatoSDK.RxWKNavigationDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  public static func currentDelegate(for object: WebKit.WKWebView) -> (any WebKit.WKNavigationDelegate)?
  public static func setCurrentDelegate(_ delegate: (any WebKit.WKNavigationDelegate)?, to object: WebKit.WKWebView)
  @objc deinit
}
@available(iOS 8.0, macOS 10.10, macOSApplicationExtension 10.10, *)
extension OndatoSDK.RxWKNavigationDelegateProxy : WebKit.WKNavigationDelegate {
}
extension OndatoSDK.Reactive where Base : UIKit.UITextField {
  public var text: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var attributedText: OndatoSDK.ControlProperty<Foundation.NSAttributedString?> {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ReplayRelay<Element> : OndatoSDK.ObservableType {
  final public func accept(_ event: Element)
  public static func create(bufferSize: Swift.Int) -> OndatoSDK.ReplayRelay<Element>
  public static func createUnbound() -> OndatoSDK.ReplayRelay<Element>
  final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func retry<TriggerObservable, Error>(when notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  public func retry<TriggerObservable>(when notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType
}
@dynamicMemberLookup public struct Reactive<Base> {
  public let base: Base
  public init(_ base: Base)
  public subscript<Property>(dynamicMember keyPath: Swift.ReferenceWritableKeyPath<Base, Property>) -> OndatoSDK.Binder<Property> where Base : AnyObject {
    get
  }
}
public protocol ReactiveCompatible {
  associatedtype ReactiveBase
  static var rx: OndatoSDK.Reactive<Self.ReactiveBase>.Type { get set }
  var rx: OndatoSDK.Reactive<Self.ReactiveBase> { get set }
}
extension OndatoSDK.ReactiveCompatible {
  public static var rx: OndatoSDK.Reactive<Self>.Type {
    get
    set
  }
  public var rx: OndatoSDK.Reactive<Self> {
    get
    set
  }
}
extension ObjectiveC.NSObject : OndatoSDK.ReactiveCompatible {
  @available(iOS 2.0, *)
  public typealias ReactiveBase = ObjectiveC.NSObject
}
extension OndatoSDK.ObservableType {
  public func delay(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
final public class ScheduledDisposable : OndatoSDK.Cancelable {
  final public let scheduler: any OndatoSDK.ImmediateSchedulerType
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(scheduler: any OndatoSDK.ImmediateSchedulerType, disposable: any OndatoSDK.Disposable)
  final public func dispose()
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.ObservableConvertibleType {
  public var values: _Concurrency.AsyncThrowingStream<Self.Element, any Swift.Error> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  public func asObservable() -> OndatoSDK.Observable<Self.Element>
}
@available(iOS 10.0, tvOS 10.0, *)
extension UIKit.UITableView : OndatoSDK.HasPrefetchDataSource {
  public typealias PrefetchDataSource = UIKit.UITableViewDataSourcePrefetching
}
@available(iOS 10.0, tvOS 10.0, *)
open class RxTableViewDataSourcePrefetchingProxy : OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSourcePrefetching>, OndatoSDK.DelegateProxyType {
  weak public var tableView: UIKit.UITableView? {
    get
  }
  public init(tableView: OndatoSDK.RxTableViewDataSourcePrefetchingProxy.ParentObject)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UITableViewDataSourcePrefetching)?, retainDelegate: Swift.Bool)
  @objc deinit
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.RxTableViewDataSourcePrefetchingProxy : UIKit.UITableViewDataSourcePrefetching {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func tableView(_ tableView: UIKit.UITableView, prefetchRowsAt indexPaths: [Foundation.IndexPath])
}
extension OndatoSDK.Reactive where Base : UIKit.UICollectionView {
  public func items<Sequence, Source>(_ source: Source) -> (_ cellFactory: @escaping (UIKit.UICollectionView, Swift.Int, Sequence.Element) -> UIKit.UICollectionViewCell) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Sequence, Cell, Source>(cellIdentifier: Swift.String, cellType: Cell.Type = Cell.self) -> (_ source: Source) -> (_ configureCell: @escaping (Swift.Int, Sequence.Element, Cell) -> Swift.Void) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Cell : UIKit.UICollectionViewCell, Source : OndatoSDK.ObservableType
  public func items<DataSource, Source>(dataSource: DataSource) -> (_ source: Source) -> any OndatoSDK.Disposable where DataSource : OndatoSDK.RxCollectionViewDataSourceType, DataSource : UIKit.UICollectionViewDataSource, Source : OndatoSDK.ObservableType, DataSource.Element == Source.Element
}
extension OndatoSDK.Reactive where Base : UIKit.UICollectionView {
  public typealias DisplayCollectionViewCellEvent = (cell: UIKit.UICollectionViewCell, at: Foundation.IndexPath)
  public typealias DisplayCollectionViewSupplementaryViewEvent = (supplementaryView: UIKit.UICollectionReusableView, elementKind: Swift.String, at: Foundation.IndexPath)
  public var dataSource: OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSource> {
    get
  }
  public func setDataSource(_ dataSource: any UIKit.UICollectionViewDataSource) -> any OndatoSDK.Disposable
  public var itemSelected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeselected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemHighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemUnhighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var willDisplayCell: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewCellEvent> {
    get
  }
  public var willDisplaySupplementaryView: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewSupplementaryViewEvent> {
    get
  }
  public var didEndDisplayingCell: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewCellEvent> {
    get
  }
  public var didEndDisplayingSupplementaryView: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewSupplementaryViewEvent> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func modelDeselected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.Reactive where Base : UIKit.UICollectionView {
  public var prefetchDataSource: OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSourcePrefetching> {
    get
  }
  public func setPrefetchDataSource(_ prefetchDataSource: any UIKit.UICollectionViewDataSourcePrefetching) -> any OndatoSDK.Disposable
  public var prefetchItems: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public var cancelPrefetchingForItems: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func take<Source>(until other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
  public func take(until predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Observable<Self.Element>
  public func take(while predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "take(until:)")
  public func takeUntil<Source>(_ other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "take(until:behavior:)")
  public func takeUntil(_ behavior: OndatoSDK.TakeBehavior, predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "take(while:)")
  public func takeWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
public enum TakeBehavior {
  case inclusive
  case exclusive
  public static func == (a: OndatoSDK.TakeBehavior, b: OndatoSDK.TakeBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_Concurrency.MainActor @preconcurrency open class RxCollectionViewDelegateProxy : OndatoSDK.RxScrollViewDelegateProxy {
  @_Concurrency.MainActor @preconcurrency weak public var collectionView: UIKit.UICollectionView? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public init(collectionView: UIKit.UICollectionView)
  @objc deinit
}
extension OndatoSDK.RxCollectionViewDelegateProxy : UIKit.UICollectionViewDelegateFlowLayout {
}
extension OndatoSDK.ObservableType {
  public static func generate(initialState: Self.Element, condition: @escaping (Self.Element) throws -> Swift.Bool, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance, iterate: @escaping (Self.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element>
}
final public class BooleanDisposable : OndatoSDK.Cancelable {
  public init()
  public init(isDisposed: Swift.Bool)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
  @objc deinit
}
extension UIKit.NSTextStorage : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.NSTextStorageDelegate
}
open class RxTextStorageDelegateProxy : OndatoSDK.DelegateProxy<UIKit.NSTextStorage, any UIKit.NSTextStorageDelegate>, OndatoSDK.DelegateProxyType {
  weak public var textStorage: UIKit.NSTextStorage? {
    get
  }
  public init(textStorage: UIKit.NSTextStorage)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxTextStorageDelegateProxy : UIKit.NSTextStorageDelegate {
}
public enum InfallibleEvent<Element> {
  case next(Element)
  case completed
}
extension OndatoSDK.Infallible {
  public typealias InfallibleObserver = (OndatoSDK.InfallibleEvent<Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping OndatoSDK.Infallible<Element>.InfallibleObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.Infallible<Element>
}
extension OndatoSDK.ObservableConvertibleType {
  public func asDriver(onErrorJustReturn: Self.Element) -> OndatoSDK.Driver<Self.Element>
  public func asDriver(onErrorDriveWith: OndatoSDK.Driver<Self.Element>) -> OndatoSDK.Driver<Self.Element>
  public func asDriver(onErrorRecover: @escaping (_ error: any Swift.Error) -> OndatoSDK.Driver<Self.Element>) -> OndatoSDK.Driver<Self.Element>
}
extension OndatoSDK.Disposables {
  public static func create() -> any OndatoSDK.Disposable
}
open class DelegateProxy<P, D> : OndatoSDK._RXDelegateProxy where P : AnyObject {
  public typealias ParentObject = P
  public typealias Delegate = D
  public init<Proxy>(parentObject: OndatoSDK.DelegateProxy<P, D>.ParentObject, delegateProxy: Proxy.Type) where P == Proxy.ParentObject, D == Proxy.Delegate, Proxy : OndatoSDK.DelegateProxy<P, D>, Proxy : OndatoSDK.DelegateProxyType
  open func sentMessage(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  open func methodInvoked(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  @objc override dynamic open func _sentMessage(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  @objc override dynamic open func _methodInvoked(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  open func forwardToDelegate() -> OndatoSDK.DelegateProxy<P, D>.Delegate?
  open func setForwardToDelegate(_ delegate: OndatoSDK.DelegateProxy<P, D>.Delegate?, retainDelegate: Swift.Bool)
  @objc(respondsToSelector:) override dynamic open func responds(to aSelector: ObjectiveC.Selector!) -> Swift.Bool
  @objc deinit
}
public typealias ItemMovedEvent = (sourceIndex: Foundation.IndexPath, destinationIndex: Foundation.IndexPath)
public typealias WillDisplayCellEvent = (cell: UIKit.UITableViewCell, indexPath: Foundation.IndexPath)
public typealias DidEndDisplayingCellEvent = (cell: UIKit.UITableViewCell, indexPath: Foundation.IndexPath)
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public var value: Self.Element {
    get async throws
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public var value: Self.Element? {
    get async throws
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public var value: Swift.Void {
    get async throws
  }
}
public protocol Cancelable : OndatoSDK.Disposable {
  var isDisposed: Swift.Bool { get }
}
extension OndatoSDK.Reactive where Base : UIKit.UIPickerView {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDelegate> {
    get
  }
  public func setDelegate(_ delegate: any UIKit.UIPickerViewDelegate) -> any OndatoSDK.Disposable
  public var dataSource: OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDataSource> {
    get
  }
  public var itemSelected: OndatoSDK.ControlEvent<(row: Swift.Int, component: Swift.Int)> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<[T]>
  public func itemTitles<Sequence, Source>(_ source: Source) -> (_ titleForRow: @escaping (Swift.Int, Sequence.Element) -> Swift.String?) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func itemAttributedTitles<Sequence, Source>(_ source: Source) -> (_ attributedTitleForRow: @escaping (Swift.Int, Sequence.Element) -> Foundation.NSAttributedString?) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Sequence, Source>(_ source: Source) -> (_ viewForRow: @escaping (Swift.Int, Sequence.Element, UIKit.UIView?) -> UIKit.UIView) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Source, Adapter>(adapter: Adapter) -> (_ source: Source) -> any OndatoSDK.Disposable where Source : OndatoSDK.ObservableType, Adapter : OndatoSDK.RxPickerViewDataSourceType, Adapter : UIKit.UIPickerViewDataSource, Adapter : UIKit.UIPickerViewDelegate, Source.Element == Adapter.Element
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
extension OndatoSDK.Reactive where Base : UIKit.UITableView {
  public func items<Sequence, Source>(_ source: Source) -> (_ cellFactory: @escaping (UIKit.UITableView, Swift.Int, Sequence.Element) -> UIKit.UITableViewCell) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Sequence, Cell, Source>(cellIdentifier: Swift.String, cellType: Cell.Type = Cell.self) -> (_ source: Source) -> (_ configureCell: @escaping (Swift.Int, Sequence.Element, Cell) -> Swift.Void) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Cell : UIKit.UITableViewCell, Source : OndatoSDK.ObservableType
  public func items<DataSource, Source>(dataSource: DataSource) -> (_ source: Source) -> any OndatoSDK.Disposable where DataSource : OndatoSDK.RxTableViewDataSourceType, DataSource : UIKit.UITableViewDataSource, Source : OndatoSDK.ObservableType, DataSource.Element == Source.Element
}
extension OndatoSDK.Reactive where Base : UIKit.UITableView {
  public var dataSource: OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSource> {
    get
  }
  public func setDataSource(_ dataSource: any UIKit.UITableViewDataSource) -> any OndatoSDK.Disposable
  public var itemSelected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeselected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemHighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemUnhighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemAccessoryButtonTapped: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemInserted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeleted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemMoved: OndatoSDK.ControlEvent<OndatoSDK.ItemMovedEvent> {
    get
  }
  public var willDisplayCell: OndatoSDK.ControlEvent<OndatoSDK.WillDisplayCellEvent> {
    get
  }
  public var didEndDisplayingCell: OndatoSDK.ControlEvent<OndatoSDK.DidEndDisplayingCellEvent> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func modelDeselected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func modelDeleted<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.Reactive where Base : UIKit.UITableView {
  public var prefetchDataSource: OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSourcePrefetching> {
    get
  }
  public func setPrefetchDataSource(_ prefetchDataSource: any UIKit.UITableViewDataSourcePrefetching) -> any OndatoSDK.Disposable
  public var prefetchRows: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public var cancelPrefetchingForRows: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
}
@_hasMissingDesignatedInitializers public class SerialDispatchQueueScheduler : OndatoSDK.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  convenience public init(internalSerialQueueName: Swift.String, serialQueueConfiguration: ((Dispatch.DispatchQueue) -> Swift.Void)? = nil, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  convenience public init(queue: Dispatch.DispatchQueue, internalSerialQueueName: Swift.String, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(macOS 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, internalSerialQueueName: Swift.String = "rx.global_dispatch_queue.serial", leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
  @objc deinit
}
extension UIKit.UICollectionView : OndatoSDK.HasDataSource {
  public typealias DataSource = UIKit.UICollectionViewDataSource
}
open class RxCollectionViewDataSourceProxy : OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSource>, OndatoSDK.DelegateProxyType {
  weak public var collectionView: UIKit.UICollectionView? {
    get
  }
  public init(collectionView: OndatoSDK.RxCollectionViewDataSourceProxy.ParentObject)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UICollectionViewDataSource)?, retainDelegate: Swift.Bool)
  @objc deinit
}
extension OndatoSDK.RxCollectionViewDataSourceProxy : UIKit.UICollectionViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
}
extension OndatoSDK.Reactive where Base : UIKit.UIApplication {
  public var isNetworkActivityIndicatorVisible: OndatoSDK.Binder<Swift.Bool> {
    get
  }
  public static var didEnterBackground: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var willEnterForeground: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var didFinishLaunching: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var didBecomeActive: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var willResignActive: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var didReceiveMemoryWarning: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var willTerminate: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var significantTimeChange: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var backgroundRefreshStatusDidChange: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var protectedDataWillBecomeUnavailable: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var protectedDataDidBecomeAvailable: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var userDidTakeScreenshot: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
}
extension UIKit.UITabBarController : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UITabBarControllerDelegate
}
open class RxTabBarControllerDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UITabBarController, any UIKit.UITabBarControllerDelegate>, OndatoSDK.DelegateProxyType {
  weak public var tabBar: UIKit.UITabBarController? {
    get
  }
  public init(tabBar: OndatoSDK.RxTabBarControllerDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxTabBarControllerDelegateProxy : UIKit.UITabBarControllerDelegate {
}
extension OndatoSDK.Disposable {
  public func disposed(by bag: OndatoSDK.DisposeBag)
}
@_inheritsConvenienceInitializers final public class DisposeBag : OndatoSDK.DisposeBase {
  public init()
  final public func insert(_ disposable: any OndatoSDK.Disposable)
  @objc deinit
}
extension OndatoSDK.DisposeBag {
  convenience public init(disposing disposables: any OndatoSDK.Disposable...)
  convenience public init(@OndatoSDK.DisposeBag.DisposableBuilder builder: () -> [any OndatoSDK.Disposable])
  convenience public init(disposing disposables: [any OndatoSDK.Disposable])
  final public func insert(_ disposables: any OndatoSDK.Disposable...)
  final public func insert(@OndatoSDK.DisposeBag.DisposableBuilder builder: () -> [any OndatoSDK.Disposable])
  final public func insert(_ disposables: [any OndatoSDK.Disposable])
  @_functionBuilder public struct DisposableBuilder {
    public static func buildBlock(_ disposables: any OndatoSDK.Disposable...) -> [any OndatoSDK.Disposable]
  }
}
extension OndatoSDK.ObservableType {
  public func toArray() -> OndatoSDK.Single<[Self.Element]>
}
extension OndatoSDK.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func interval(_ period: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval? = nil, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func skip(_ count: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func skip(_ duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
@_inheritsConvenienceInitializers final public class AsyncSubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.ObserverType {
  public typealias SubjectObserverType = OndatoSDK.AsyncSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: OndatoSDK.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObserver() -> OndatoSDK.AsyncSubject<Element>
  public typealias Observer = OndatoSDK.AsyncSubject<Element>
  @objc deinit
}
extension OndatoSDK.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func range(start: Self.Element, count: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.BehaviorRelay {
  final public func asDriver() -> OndatoSDK.Driver<Element>
}
extension OndatoSDK.ObservableType {
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.Observable<Out> where Object : AnyObject
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.Observable<(Object, Self.Element)> where Object : AnyObject
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
extension OndatoSDK.ObservableType {
  public func throttle(_ dueTime: OndatoSDK.RxTimeInterval, latest: Swift.Bool = true, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> OndatoSDK.Observable<Result>
}
extension OndatoSDK.ObservableType {
  public func skip(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "skip(while:)")
  public func skipWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
@available(iOS 10.0, tvOS 10.0, *)
extension UIKit.UICollectionView : OndatoSDK.HasPrefetchDataSource {
  public typealias PrefetchDataSource = UIKit.UICollectionViewDataSourcePrefetching
}
@available(iOS 10.0, tvOS 10.0, *)
open class RxCollectionViewDataSourcePrefetchingProxy : OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSourcePrefetching>, OndatoSDK.DelegateProxyType {
  weak public var collectionView: UIKit.UICollectionView? {
    get
  }
  public init(collectionView: OndatoSDK.RxCollectionViewDataSourcePrefetchingProxy.ParentObject)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UICollectionViewDataSourcePrefetching)?, retainDelegate: Swift.Bool)
  @objc deinit
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.RxCollectionViewDataSourcePrefetchingProxy : UIKit.UICollectionViewDataSourcePrefetching {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, prefetchItemsAt indexPaths: [Foundation.IndexPath])
}
extension UIKit.UITabBar : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UITabBarDelegate
}
open class RxTabBarDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UITabBar, any UIKit.UITabBarDelegate>, OndatoSDK.DelegateProxyType {
  weak public var tabBar: UIKit.UITabBar? {
    get
  }
  public init(tabBar: OndatoSDK.RxTabBarDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  open class func currentDelegate(for object: OndatoSDK.RxTabBarDelegateProxy.ParentObject) -> (any UIKit.UITabBarDelegate)?
  open class func setCurrentDelegate(_ delegate: (any UIKit.UITabBarDelegate)?, to object: OndatoSDK.RxTabBarDelegateProxy.ParentObject)
  @objc deinit
}
extension OndatoSDK.RxTabBarDelegateProxy : UIKit.UITabBarDelegate {
}
extension OndatoSDK.Reactive where Base : UIKit.UISlider {
  public var value: OndatoSDK.ControlProperty<Swift.Float> {
    get
  }
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public func andThen<Element>(_ second: OndatoSDK.Single<Element>) -> OndatoSDK.Single<Element>
  public func andThen<Element>(_ second: OndatoSDK.Maybe<Element>) -> OndatoSDK.Maybe<Element>
  public func andThen(_ second: OndatoSDK.Completable) -> OndatoSDK.Completable
  public func andThen<Element>(_ second: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.ControlProperty {
  public func asDriver() -> OndatoSDK.Driver<OndatoSDK.ControlProperty<PropertyType>.Element>
}
public class ConcurrentDispatchQueueScheduler : OndatoSDK.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  public init(queue: Dispatch.DispatchQueue, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  convenience public init(qos: Dispatch.DispatchQoS, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func from(optional: Self.Element?) -> OndatoSDK.Observable<Self.Element>
  public static func from(optional: Self.Element?, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
public protocol Disposable {
  func dispose()
}
extension OndatoSDK.Reactive where Base : UIKit.NSTextStorage {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.NSTextStorage, any UIKit.NSTextStorageDelegate> {
    get
  }
  public var didProcessEditingRangeChangeInLength: OndatoSDK.Observable<(editedMask: UIKit.NSTextStorage.EditActions, editedRange: Foundation.NSRange, delta: Swift.Int)> {
    get
  }
}
public protocol ObserverType {
  associatedtype Element
  func on(_ event: OndatoSDK.Event<Self.Element>)
}
extension OndatoSDK.ObserverType {
  public func onNext(_ element: Self.Element)
  public func onCompleted()
  public func onError(_ error: any Swift.Error)
}
extension OndatoSDK.ObservableType {
  public static func never() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func startWith(_ elements: Self.Element...) -> OndatoSDK.Observable<Self.Element>
}
public typealias RxTimeInterval = Dispatch.DispatchTimeInterval
public typealias RxTime = Foundation.Date
public protocol SchedulerType : OndatoSDK.ImmediateSchedulerType {
  var now: OndatoSDK.RxTime { get }
  func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
}
extension OndatoSDK.SchedulerType {
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
}
@_inheritsConvenienceInitializers final public class SingleAssignmentDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func setDisposable(_ disposable: any OndatoSDK.Disposable)
  final public func dispose()
  @objc deinit
}
extension OndatoSDK.ControlEvent {
  public func asDriver() -> OndatoSDK.Driver<OndatoSDK.ControlEvent<PropertyType>.Element>
}
public struct HistoricalSchedulerTimeConverter : OndatoSDK.VirtualTimeConverterType {
  public typealias VirtualTimeUnit = OndatoSDK.RxTime
  public typealias VirtualTimeIntervalUnit = Foundation.TimeInterval
  public func convertFromVirtualTime(_ virtualTime: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> OndatoSDK.RxTime
  public func convertToVirtualTime(_ time: OndatoSDK.RxTime) -> OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func convertFromVirtualTimeInterval(_ virtualTimeInterval: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  public func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit
  public func offsetVirtualTime(_ time: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit, offset: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func compareVirtualTime(_ lhs: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit, _ rhs: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> OndatoSDK.VirtualTimeComparison
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> OndatoSDK.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : OndatoSDK.KVORepresentable
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : OndatoSDK.KVORepresentable
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConnectableObservable<Element> : OndatoSDK.Observable<Element>, OndatoSDK.ConnectableObservableType {
  public func connect() -> any OndatoSDK.Disposable
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func multicast<Subject, Result>(_ subjectSelector: @escaping () throws -> Subject, selector: @escaping (OndatoSDK.Observable<Subject.Element>) throws -> OndatoSDK.Observable<Result>) -> OndatoSDK.Observable<Result> where Subject : OndatoSDK.SubjectType, Self.Element == Subject.Observer.Element
}
extension OndatoSDK.ObservableType {
  public func publish() -> OndatoSDK.ConnectableObservable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func replay(_ bufferSize: Swift.Int) -> OndatoSDK.ConnectableObservable<Self.Element>
  public func replayAll() -> OndatoSDK.ConnectableObservable<Self.Element>
}
extension OndatoSDK.ConnectableObservableType {
  public func refCount() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func multicast<Subject>(_ subject: Subject) -> OndatoSDK.ConnectableObservable<Subject.Element> where Subject : OndatoSDK.SubjectType, Self.Element == Subject.Observer.Element
  public func multicast<Subject>(makeSubject: @escaping () -> Subject) -> OndatoSDK.ConnectableObservable<Subject.Element> where Subject : OndatoSDK.SubjectType, Self.Element == Subject.Observer.Element
}
@_hasMissingDesignatedInitializers final public class RefCountDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(disposable: any OndatoSDK.Disposable)
  final public func retain() -> any OndatoSDK.Disposable
  final public func dispose()
  @objc deinit
}
public protocol RxCollectionViewDataSourceType {
  associatedtype Element
  func collectionView(_ collectionView: UIKit.UICollectionView, observedEvent: OndatoSDK.Event<Self.Element>)
}
public struct PrimitiveSequence<Trait, Element> {
}
public protocol PrimitiveSequenceType {
  associatedtype Trait
  associatedtype Element
  var primitiveSequence: OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element> { get }
}
extension OndatoSDK.PrimitiveSequence : OndatoSDK.PrimitiveSequenceType {
  public var primitiveSequence: OndatoSDK.PrimitiveSequence<Trait, Element> {
    get
  }
}
extension OndatoSDK.PrimitiveSequence : OndatoSDK.ObservableConvertibleType {
  public func asObservable() -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.PrimitiveSequence {
  public static func deferred(_ observableFactory: @escaping () throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func delay(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func delaySubscription(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func observe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "observe(on:)")
  public func observeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func subscribe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "subscribe(on:)")
  public func subscribeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "catch(_:)")
  public func catchError(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func `catch`(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func retry<TriggerObservable, Error>(when notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  public func retry<TriggerObservable>(when notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, primitiveSequenceFactory: @escaping (Resource) throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element> where Resource : OndatoSDK.Disposable
  public func timeout(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func timeout(_ dueTime: OndatoSDK.RxTimeInterval, other: OndatoSDK.PrimitiveSequence<Trait, Element>, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
public protocol DelegateProxyType : AnyObject {
  associatedtype ParentObject : AnyObject
  associatedtype Delegate
  static func registerKnownImplementations()
  static var identifier: Swift.UnsafeRawPointer { get }
  static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
  func forwardToDelegate() -> Self.Delegate?
  func setForwardToDelegate(_ forwardToDelegate: Self.Delegate?, retainDelegate: Swift.Bool)
}
extension OndatoSDK.DelegateProxyType {
  public static var identifier: Swift.UnsafeRawPointer {
    get
  }
}
extension OndatoSDK.DelegateProxyType {
  public static func register<Parent>(make: @escaping (Parent) -> Self)
  public static func createProxy(for object: Swift.AnyObject) -> Self
  public static func proxy(for object: Self.ParentObject) -> Self
  public static func installForwardDelegate(_ forwardDelegate: Self.Delegate, retainDelegate: Swift.Bool, onProxyForObject object: Self.ParentObject) -> any OndatoSDK.Disposable
}
public protocol HasDelegate : AnyObject {
  associatedtype Delegate
  var delegate: Self.Delegate? { get set }
}
extension OndatoSDK.DelegateProxyType where Self.Delegate == Self.ParentObject.Delegate, Self.ParentObject : OndatoSDK.HasDelegate {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
public protocol HasDataSource : AnyObject {
  associatedtype DataSource
  var dataSource: Self.DataSource? { get set }
}
extension OndatoSDK.DelegateProxyType where Self.Delegate == Self.ParentObject.DataSource, Self.ParentObject : OndatoSDK.HasDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
@available(iOS 10.0, tvOS 10.0, *)
public protocol HasPrefetchDataSource : AnyObject {
  associatedtype PrefetchDataSource
  var prefetchDataSource: Self.PrefetchDataSource? { get set }
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.DelegateProxyType where Self.Delegate == Self.ParentObject.PrefetchDataSource, Self.ParentObject : OndatoSDK.HasPrefetchDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
extension Swift.Int : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int.KVOType)
}
extension Swift.Int32 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int32.KVOType)
}
extension Swift.Int64 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int64.KVOType)
}
extension Swift.UInt : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt.KVOType)
}
extension Swift.UInt32 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt32.KVOType)
}
extension Swift.UInt64 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt64.KVOType)
}
extension Swift.Bool : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Bool.KVOType)
}
public enum SubjectLifetimeScope {
  case whileConnected
  case forever
  public static func == (a: OndatoSDK.SubjectLifetimeScope, b: OndatoSDK.SubjectLifetimeScope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func share(replay: Swift.Int = 0, scope: OndatoSDK.SubjectLifetimeScope = .whileConnected) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : OndatoSDK.ObservableType
  public static func combineLatest<Collection>(_ collection: Collection) -> OndatoSDK.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : OndatoSDK.ObservableType
}
@_inheritsConvenienceInitializers final public class PublishSubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.Cancelable, OndatoSDK.ObserverType {
  public typealias SubjectObserverType = OndatoSDK.PublishSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: OndatoSDK.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObserver() -> OndatoSDK.PublishSubject<Element>
  final public func dispose()
  public typealias Observer = OndatoSDK.PublishSubject<Element>
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, observableFactory: @escaping (Resource) throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element> where Resource : OndatoSDK.Disposable
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ReplaySubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.ObserverType, OndatoSDK.Disposable {
  public typealias SubjectObserverType = OndatoSDK.ReplaySubject<Element>
  public var hasObservers: Swift.Bool {
    get
  }
  public func on(_ event: OndatoSDK.Event<Element>)
  public func asObserver() -> OndatoSDK.ReplaySubject<Element>
  public func dispose()
  public static func create(bufferSize: Swift.Int) -> OndatoSDK.ReplaySubject<Element>
  public static func createUnbounded() -> OndatoSDK.ReplaySubject<Element>
  public typealias Observer = OndatoSDK.ReplaySubject<Element>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Observable<Element> : OndatoSDK.ObservableType {
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UIBarButtonItem {
  public var tap: OndatoSDK.ControlEvent<()> {
    get
  }
}
public enum SharingScheduler {
  public static var make: () -> any OndatoSDK.SchedulerType {
    get
  }
  public static func mock(scheduler: any OndatoSDK.SchedulerType, action: () throws -> Swift.Void) rethrows
  public static func mock(makeScheduler: @escaping () -> any OndatoSDK.SchedulerType, action: () throws -> Swift.Void) rethrows
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func map<Result>(_ selector: @escaping (Self.Element) -> Result) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Result>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func compactMap<Result>(_ selector: @escaping (Self.Element) -> Result?) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Result>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func filter(_ predicate: @escaping (Self.Element) -> Swift.Bool) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element : OndatoSDK.SharedSequenceConvertibleType {
  public func switchLatest() -> OndatoSDK.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func flatMapLatest<Sharing, Result>(_ selector: @escaping (Self.Element) -> OndatoSDK.SharedSequence<Sharing, Result>) -> OndatoSDK.SharedSequence<Sharing, Result> where Sharing : OndatoSDK.SharingStrategyProtocol
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func flatMapFirst<Sharing, Result>(_ selector: @escaping (Self.Element) -> OndatoSDK.SharedSequence<Sharing, Result>) -> OndatoSDK.SharedSequence<Sharing, Result> where Sharing : OndatoSDK.SharingStrategyProtocol
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func `do`(onNext: ((Self.Element) -> Swift.Void)? = nil, afterNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, afterCompleted: (() -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) -> Key) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) -> K, comparer: @escaping (K, K) -> Swift.Bool) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func flatMap<Sharing, Result>(_ selector: @escaping (Self.Element) -> OndatoSDK.SharedSequence<Sharing, Result>) -> OndatoSDK.SharedSequence<Sharing, Result> where Sharing : OndatoSDK.SharingStrategyProtocol
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public static func merge<Collection>(_ sources: Collection) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: [OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>]) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>...) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element : OndatoSDK.SharedSequenceConvertibleType {
  public func merge() -> OndatoSDK.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> OndatoSDK.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func throttle(_ dueTime: OndatoSDK.RxTimeInterval, latest: Swift.Bool = true) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public func debounce(_ dueTime: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) -> A) -> OndatoSDK.SharedSequence<Self.SharingStrategy, A>
}
extension OndatoSDK.SharedSequence {
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence {
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> OndatoSDK.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func zip<Collection>(_ collection: Collection) -> OndatoSDK.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> OndatoSDK.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func combineLatest<Collection>(_ collection: Collection) -> OndatoSDK.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.SignalSharingStrategy {
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Out> where Object : AnyObject
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (Object, Self.Element)> where Object : AnyObject
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.DriverSharingStrategy {
  @available(*, unavailable, message: "withUnretained has been deprecated for Driver. Consider using `drive(with:onNext:onCompleted:onDisposed:)`, instead")
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Out> where Object : AnyObject
  @available(*, unavailable, message: "withUnretained has been deprecated for Driver. Consider using `drive(with:onNext:onCompleted:onDisposed:)`, instead")
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (Object, Self.Element)> where Object : AnyObject
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func withLatestFrom<SecondO, ResultType>(_ second: SecondO, resultSelector: @escaping (Self.Element, SecondO.Element) -> ResultType) -> OndatoSDK.SharedSequence<Self.SharingStrategy, ResultType> where SecondO : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == SecondO.SharingStrategy
  public func withLatestFrom<SecondO>(_ second: SecondO) -> OndatoSDK.SharedSequence<Self.SharingStrategy, SecondO.Element> where SecondO : OndatoSDK.SharedSequenceConvertibleType
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func skip(_ count: Swift.Int) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func startWith(_ element: Self.Element) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func delay(_ dueTime: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
public struct Binder<Value> : OndatoSDK.ObserverType {
  public typealias Element = Value
  public init<Target>(_ target: Target, scheduler: any OndatoSDK.ImmediateSchedulerType = MainScheduler(), binding: @escaping (Target, Value) -> Swift.Void) where Target : AnyObject
  public func on(_ event: OndatoSDK.Event<Value>)
  public func asObserver() -> OndatoSDK.AnyObserver<Value>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.SharedSequence {
  @_Concurrency.MainActor public var values: _Concurrency.AsyncStream<Element> {
    get
  }
}
extension OndatoSDK.InfallibleType {
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
}
extension OndatoSDK.ObservableType {
  public func buffer(timeSpan: OndatoSDK.RxTimeInterval, count: Swift.Int, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<[Self.Element]>
}
extension OndatoSDK.ObservableType {
  public static func deferred(_ observableFactory: @escaping () throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
}
public protocol InfallibleType : OndatoSDK.ObservableConvertibleType {
}
public struct Infallible<Element> : OndatoSDK.InfallibleType {
  public func asObservable() -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.InfallibleType {
  public func subscribe<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func subscribe(_ on: @escaping (OndatoSDK.Event<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
}
extension OndatoSDK.Reactive where Base : UIKit.UIRefreshControl {
  public var isRefreshing: OndatoSDK.Binder<Swift.Bool> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIDatePicker {
  public var date: OndatoSDK.ControlProperty<Foundation.Date> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Foundation.Date> {
    get
  }
  public var countDownDuration: OndatoSDK.ControlProperty<Foundation.TimeInterval> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIStepper {
  public var value: OndatoSDK.ControlProperty<Swift.Double> {
    get
  }
}
public protocol SubjectType : OndatoSDK.ObservableType {
  associatedtype Observer : OndatoSDK.ObserverType
  func asObserver() -> Self.Observer
}
extension OndatoSDK.ObservableType {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func ignoreElements() -> OndatoSDK.Observable<Swift.Never>
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.EventConvertible {
  public func dematerialize() -> OndatoSDK.Observable<Self.Element.Element>
}
extension OndatoSDK.ObservableType {
  public static func of(_ elements: Self.Element..., scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public static func from(_ array: [Self.Element], scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
  public static func from<Sequence>(_ sequence: Sequence, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Self.Element == Sequence.Element
}
extension OndatoSDK.InfallibleType {
  public static func just(_ element: Self.Element) -> OndatoSDK.Infallible<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Infallible<Self.Element>
  public static func never() -> OndatoSDK.Infallible<Self.Element>
  public static func empty() -> OndatoSDK.Infallible<Self.Element>
  public static func deferred(_ observableFactory: @escaping () throws -> OndatoSDK.Infallible<Self.Element>) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.Infallible {
  public static func of(_ elements: Element..., scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Infallible<Element>
}
extension OndatoSDK.Infallible {
  public static func from(_ array: [Element], scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Infallible<Element>
  public static func from<Sequence>(_ sequence: Sequence, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Infallible<Element> where Element == Sequence.Element, Sequence : Swift.Sequence
}
extension OndatoSDK.InfallibleType {
  public func filter(_ predicate: @escaping (Self.Element) -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func map<Result>(_ transform: @escaping (Self.Element) -> Result) -> OndatoSDK.Infallible<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) -> Result?) -> OndatoSDK.Infallible<Result>
}
extension OndatoSDK.InfallibleType where Self.Element : Swift.Comparable {
  public func distinctUntilChanged() -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) throws -> Key) -> OndatoSDK.Infallible<Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) throws -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) throws -> K, comparer: @escaping (K, K) throws -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
  public func distinctUntilChanged<Property>(at keyPath: Swift.KeyPath<Self.Element, Property>) -> OndatoSDK.Infallible<Self.Element> where Property : Swift.Equatable
}
extension OndatoSDK.InfallibleType {
  public func debounce(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Infallible<Self.Element>
  public func throttle(_ dueTime: OndatoSDK.RxTimeInterval, latest: Swift.Bool = true, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func flatMap<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
  public func flatMapFirst<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.InfallibleType {
  public func concat<Source>(_ second: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.ObservableConvertibleType, Self.Element == Source.Element
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.Infallible<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Infallible<Self.Element>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.Infallible<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Infallible<Self.Element>
  public static func concat(_ sources: OndatoSDK.Infallible<Self.Element>...) -> OndatoSDK.Infallible<Self.Element>
  public func concatMap<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.InfallibleType {
  public static func merge<Collection>(_ sources: Collection) -> OndatoSDK.Infallible<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Infallible<Self.Element>
  public static func merge(_ sources: [OndatoSDK.Infallible<Self.Element>]) -> OndatoSDK.Infallible<Self.Element>
  public static func merge(_ sources: OndatoSDK.Infallible<Self.Element>...) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.Infallible {
  public func `do`(onNext: ((Element) throws -> Swift.Void)? = nil, afterNext: ((Element) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Infallible<Element>
}
extension OndatoSDK.InfallibleType {
  public func scan<Seed>(into seed: Seed, accumulator: @escaping (inout Seed, Self.Element) -> Swift.Void) -> OndatoSDK.Infallible<Seed>
  public func scan<Seed>(_ seed: Seed, accumulator: @escaping (Seed, Self.Element) -> Seed) -> OndatoSDK.Infallible<Seed>
}
extension OndatoSDK.InfallibleType {
  public func startWith(_ element: Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func take<Source>(until other: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.InfallibleType
  public func take<Source>(until other: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.ObservableType
  public func take(until predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Infallible<Self.Element>
  public func take(while predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Infallible<Self.Element>
  public func take(_ count: Swift.Int) -> OndatoSDK.Infallible<Self.Element>
  public func take(for duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Infallible<Self.Element>
  public func skip(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
  public func skip<Source>(until other: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.ObservableType
}
extension OndatoSDK.InfallibleType {
  public func share(replay: Swift.Int = 0, scope: OndatoSDK.SubjectLifetimeScope = .whileConnected) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.Infallible<Out> where Object : AnyObject
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.Infallible<(Object, Self.Element)> where Object : AnyObject
}
extension OndatoSDK.InfallibleType {
  public func withLatestFrom<Source, ResultType>(_ second: Source, resultSelector: @escaping (Self.Element, Source.Element) throws -> ResultType) -> OndatoSDK.Infallible<ResultType> where Source : OndatoSDK.InfallibleType
  public func withLatestFrom<Source>(_ second: Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.InfallibleType
}
extension OndatoSDK.ObservableType {
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.InfallibleType
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.ObservableConvertibleType {
  public func switchLatest() -> OndatoSDK.Observable<Self.Element.Element>
}
extension OndatoSDK.ObservableType {
  public func skip<Source>(until other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "skip(until:)")
  public func skipUntil<Source>(_ other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
}
extension UIKit.UIPickerView : OndatoSDK.HasDataSource {
  public typealias DataSource = UIKit.UIPickerViewDataSource
}
public class RxPickerViewDataSourceProxy : OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDataSource>, OndatoSDK.DelegateProxyType {
  weak public var pickerView: UIKit.UIPickerView? {
    get
  }
  public init(pickerView: OndatoSDK.RxPickerViewDataSourceProxy.ParentObject)
  public static func registerKnownImplementations()
  override public func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UIPickerViewDataSource)?, retainDelegate: Swift.Bool)
  @objc deinit
}
extension OndatoSDK.RxPickerViewDataSourceProxy : UIKit.UIPickerViewDataSource {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
}
extension OndatoSDK.ObservableType {
  public func debounce(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension UIKit.UIScrollView : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UIScrollViewDelegate
}
open class RxScrollViewDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UIScrollView, any UIKit.UIScrollViewDelegate>, OndatoSDK.DelegateProxyType {
  weak public var scrollView: UIKit.UIScrollView? {
    get
  }
  public init(scrollView: OndatoSDK.RxScrollViewDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxScrollViewDelegateProxy : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
}
extension OndatoSDK.ObservableType {
  public func concat<Source>(_ second: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableConvertibleType, Self.Element == Source.Element
}
extension OndatoSDK.ObservableType {
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Observable<Self.Element>
  public static func concat(_ sources: OndatoSDK.Observable<Self.Element>...) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> OndatoSDK.Observable<Result>
}
public class OperationQueueScheduler : OndatoSDK.ImmediateSchedulerType {
  final public let operationQueue: Foundation.OperationQueue
  final public let queuePriority: Foundation.Operation.QueuePriority
  public init(operationQueue: Foundation.OperationQueue, queuePriority: Foundation.Operation.QueuePriority = .normal)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func flatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.ObservableType {
  public func flatMapFirst<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.ObservableConvertibleType {
  public func merge() -> OndatoSDK.Observable<Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> OndatoSDK.Observable<Self.Element.Element>
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.ObservableConvertibleType {
  public func concat() -> OndatoSDK.Observable<Self.Element.Element>
}
extension OndatoSDK.ObservableType {
  public static func merge<Collection>(_ sources: Collection) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Observable<Self.Element>
  public static func merge(_ sources: [OndatoSDK.Observable<Self.Element>]) -> OndatoSDK.Observable<Self.Element>
  public static func merge(_ sources: OndatoSDK.Observable<Self.Element>...) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func concatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
public protocol ControlEventType : OndatoSDK.ObservableType {
  func asControlEvent() -> OndatoSDK.ControlEvent<Self.Element>
}
public struct ControlEvent<PropertyType> : OndatoSDK.ControlEventType {
  public typealias Element = PropertyType
  public init<Ev>(events: Ev) where PropertyType == Ev.Element, Ev : OndatoSDK.ObservableType
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where PropertyType == Observer.Element, Observer : OndatoSDK.ObserverType
  public func asObservable() -> OndatoSDK.Observable<OndatoSDK.ControlEvent<PropertyType>.Element>
  public func asControlEvent() -> OndatoSDK.ControlEvent<OndatoSDK.ControlEvent<PropertyType>.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, _ source6: OndatoSDK.Infallible<E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, _ source6: OndatoSDK.Infallible<E6>, _ source7: OndatoSDK.Infallible<E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, _ source6: OndatoSDK.Infallible<E6>, _ source7: OndatoSDK.Infallible<E7>, _ source8: OndatoSDK.Infallible<E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.ObservableConvertibleType {
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorJustReturn: Self.Element) -> OndatoSDK.SharedSequence<S, Self.Element> where S : OndatoSDK.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorDriveWith: OndatoSDK.SharedSequence<S, Self.Element>) -> OndatoSDK.SharedSequence<S, Self.Element> where S : OndatoSDK.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorRecover: @escaping (_ error: any Swift.Error) -> OndatoSDK.SharedSequence<S, Self.Element>) -> OndatoSDK.SharedSequence<S, Self.Element> where S : OndatoSDK.SharingStrategyProtocol
}
public typealias Signal<Element> = OndatoSDK.SharedSequence<OndatoSDK.SignalSharingStrategy, Element>
public struct SignalSharingStrategy : OndatoSDK.SharingStrategyProtocol {
  public static var scheduler: any OndatoSDK.SchedulerType {
    get
  }
  public static func share<Element>(_ source: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.SignalSharingStrategy {
  public func asSignal() -> OndatoSDK.Signal<Self.Element>
}
public struct SharedSequence<SharingStrategy, Element> : OndatoSDK.SharedSequenceConvertibleType, OndatoSDK.ObservableConvertibleType where SharingStrategy : OndatoSDK.SharingStrategyProtocol {
  public func asObservable() -> OndatoSDK.Observable<Element>
  public func asSharedSequence() -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
public protocol SharingStrategyProtocol {
  static var scheduler: any OndatoSDK.SchedulerType { get }
  static func share<Element>(_ source: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
public protocol SharedSequenceConvertibleType : OndatoSDK.ObservableConvertibleType {
  associatedtype SharingStrategy : OndatoSDK.SharingStrategyProtocol
  func asSharedSequence() -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func asObservable() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.SharedSequence {
  public static func empty() -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func never() -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func just(_ element: Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func deferred(_ observableFactory: @escaping () -> OndatoSDK.SharedSequence<SharingStrategy, Element>) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func of(_ elements: Element...) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence {
  public static func from(_ array: [Element]) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func from<Sequence>(_ sequence: Sequence) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where Element == Sequence.Element, Sequence : Swift.Sequence
  public static func from(optional: Element?) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence where Element : Swift.FixedWidthInteger {
  public static func interval(_ period: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence where Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension OndatoSDK.ObservableType {
  public func `catch`(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "catch(_:)")
  public func catchError(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
  public func catchAndReturn(_ element: Self.Element) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "catchAndReturn(_:)")
  public func catchErrorJustReturn(_ element: Self.Element) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  @available(*, deprecated, renamed: "catch(onSuccess:onFailure:onDisposed:)")
  public static func catchError<Sequence>(_ sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
  public static func `catch`<Sequence>(sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func retry() -> OndatoSDK.Observable<Self.Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) throws -> Key) -> OndatoSDK.Observable<Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) throws -> K, comparer: @escaping (K, K) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  public func distinctUntilChanged<Property>(at keyPath: Swift.KeyPath<Self.Element, Property>) -> OndatoSDK.Observable<Self.Element> where Property : Swift.Equatable
}
extension OndatoSDK.ObservableType {
  public static func just(_ element: Self.Element) -> OndatoSDK.Observable<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  @available(*, deprecated, renamed: "element(at:)")
  public func elementAt(_ index: Swift.Int) -> OndatoSDK.Observable<Self.Element>
  public func element(at index: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func take(_ count: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func take(for duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "take(for:scheduler:)")
  public func take(_ duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension CoreFoundation.CGRect : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreFoundation.CGRect.KVOType)
}
extension CoreFoundation.CGPoint : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreFoundation.CGPoint.KVOType)
}
extension CoreFoundation.CGSize : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreFoundation.CGSize.KVOType)
}
@_Concurrency.MainActor @preconcurrency open class RxTextViewDelegateProxy : OndatoSDK.RxScrollViewDelegateProxy {
  @_Concurrency.MainActor @preconcurrency weak public var textView: UIKit.UITextView? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public init(textView: UIKit.UITextView)
  @objc deinit
}
extension OndatoSDK.RxTextViewDelegateProxy : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor @preconcurrency @objc dynamic open func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
}
public struct GroupedObservable<Key, Element> : OndatoSDK.ObservableType {
  public let key: Key
  public init(key: Key, source: OndatoSDK.Observable<Element>)
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  public func asObservable() -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.ObservableType {
  public func subscribe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "subscribe(on:)")
  public func subscribeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
public enum Hooks {
  public static var recordCallStackOnError: Swift.Bool
}
public enum MaybeTrait {
}
public typealias Maybe<Element> = OndatoSDK.PrimitiveSequence<OndatoSDK.MaybeTrait, Element>
@frozen public enum MaybeEvent<Element> {
  case success(Element)
  case error(any Swift.Error)
  case completed
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public typealias MaybeObserver = (OndatoSDK.MaybeEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.MaybeObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (OndatoSDK.MaybeEvent<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onSuccess: ((Object, Self.Element) -> Swift.Void)? = nil, onError: ((Object, any Swift.Error) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func just(_ element: Self.Element) -> OndatoSDK.Maybe<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Maybe<Self.Element>
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Maybe<Self.Element>
  public static func never() -> OndatoSDK.Maybe<Self.Element>
  public static func empty() -> OndatoSDK.Maybe<Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Maybe<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> OndatoSDK.Maybe<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> OndatoSDK.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Maybe<Result>) -> OndatoSDK.Maybe<Result>
  public func ifEmpty(default: Self.Element) -> OndatoSDK.Single<Self.Element>
  public func ifEmpty(switchTo other: OndatoSDK.Maybe<Self.Element>) -> OndatoSDK.Maybe<Self.Element>
  public func ifEmpty(switchTo other: OndatoSDK.Single<Self.Element>) -> OndatoSDK.Single<Self.Element>
  public func catchAndReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  @available(*, deprecated, renamed: "catchAndReturn(_:)")
  public func catchErrorJustReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
public protocol VirtualTimeConverterType {
  associatedtype VirtualTimeUnit
  associatedtype VirtualTimeIntervalUnit
  func convertFromVirtualTime(_ virtualTime: Self.VirtualTimeUnit) -> OndatoSDK.RxTime
  func convertToVirtualTime(_ time: OndatoSDK.RxTime) -> Self.VirtualTimeUnit
  func convertFromVirtualTimeInterval(_ virtualTimeInterval: Self.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Self.VirtualTimeIntervalUnit
  func offsetVirtualTime(_ time: Self.VirtualTimeUnit, offset: Self.VirtualTimeIntervalUnit) -> Self.VirtualTimeUnit
  func compareVirtualTime(_ lhs: Self.VirtualTimeUnit, _ rhs: Self.VirtualTimeUnit) -> OndatoSDK.VirtualTimeComparison
}
public enum VirtualTimeComparison {
  case lessThan
  case equal
  case greaterThan
  public static func == (a: OndatoSDK.VirtualTimeComparison, b: OndatoSDK.VirtualTimeComparison) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func reduce<A, Result>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A, mapResult: @escaping (A) throws -> Result) -> OndatoSDK.Observable<Result>
  public func reduce<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> OndatoSDK.Observable<A>
}
extension OndatoSDK.Reactive where Base : UIKit.UISwitch {
  public var isOn: OndatoSDK.ControlProperty<Swift.Bool> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.Bool> {
    get
  }
}
public protocol ImmediateSchedulerType {
  func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
}
extension OndatoSDK.ImmediateSchedulerType {
  public func scheduleRecursive<State>(_ state: State, action: @escaping (_ state: State, _ recurse: (State) -> Swift.Void) -> Swift.Void) -> any OndatoSDK.Disposable
}
@_inheritsConvenienceInitializers final public class CompositeDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  public struct DisposeKey {
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  public init(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable)
  public init(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable)
  public init(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable, _ disposable4: any OndatoSDK.Disposable, _ disposables: any OndatoSDK.Disposable...)
  public init(disposables: [any OndatoSDK.Disposable])
  final public func insert(_ disposable: any OndatoSDK.Disposable) -> OndatoSDK.CompositeDisposable.DisposeKey?
  final public var count: Swift.Int {
    get
  }
  final public func remove(for disposeKey: OndatoSDK.CompositeDisposable.DisposeKey)
  final public func dispose()
  @objc deinit
}
extension OndatoSDK.Disposables {
  public static func create(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable) -> any OndatoSDK.Cancelable
  public static func create(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable, _ disposables: any OndatoSDK.Disposable...) -> any OndatoSDK.Cancelable
  public static func create(_ disposables: [any OndatoSDK.Disposable]) -> any OndatoSDK.Cancelable
}
extension OndatoSDK.ObservableType {
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind<Object>(with object: Object, onNext: @escaping (Object, Self.Element) -> Swift.Void) -> any OndatoSDK.Disposable where Object : AnyObject
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> any OndatoSDK.Disposable
}
@_inheritsConvenienceInitializers final public class SerialDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public var disposable: any OndatoSDK.Disposable {
    get
    set(newDisposable)
  }
  final public func dispose()
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func subscribe(_ on: @escaping (OndatoSDK.Event<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onError: ((Object, any Swift.Error) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onNext: ((Self.Element) -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.Hooks {
  public typealias DefaultErrorHandler = (_ subscriptionCallStack: [Swift.String], _ error: any Swift.Error) -> Swift.Void
  public typealias CustomCaptureSubscriptionCallstack = () -> [Swift.String]
  public static var defaultErrorHandler: OndatoSDK.Hooks.DefaultErrorHandler {
    get
    set
  }
  public static var customCaptureSubscriptionCallstack: OndatoSDK.Hooks.CustomCaptureSubscriptionCallstack {
    get
    set
  }
}
extension UIKit.UIPickerView : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UIPickerViewDelegate
}
open class RxPickerViewDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDelegate>, OndatoSDK.DelegateProxyType {
  weak public var pickerView: UIKit.UIPickerView? {
    get
  }
  public init(pickerView: OndatoSDK.RxPickerViewDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxPickerViewDelegateProxy : UIKit.UIPickerViewDelegate {
}
public class HistoricalScheduler : OndatoSDK.VirtualTimeScheduler<OndatoSDK.HistoricalSchedulerTimeConverter> {
  public init(initialClock: OndatoSDK.RxTime = Date(timeIntervalSince1970: 0))
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func repeatElement(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
}
public protocol SectionedViewDataSourceType {
  func model(at indexPath: Foundation.IndexPath) throws -> Any
}
public protocol ObservableType : OndatoSDK.ObservableConvertibleType {
  func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
}
extension OndatoSDK.ObservableType {
  public func asObservable() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UIScrollView {
  public typealias EndZoomEvent = (view: UIKit.UIView?, scale: CoreFoundation.CGFloat)
  public typealias WillEndDraggingEvent = (velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UIScrollView, any UIKit.UIScrollViewDelegate> {
    get
  }
  public var contentOffset: OndatoSDK.ControlProperty<CoreFoundation.CGPoint> {
    get
  }
  public var didScroll: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginDecelerating: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var didEndDecelerating: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginDragging: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willEndDragging: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.WillEndDraggingEvent> {
    get
  }
  public var didEndDragging: OndatoSDK.ControlEvent<Swift.Bool> {
    get
  }
  public var didZoom: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var didScrollToTop: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var didEndScrollingAnimation: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginZooming: OndatoSDK.ControlEvent<UIKit.UIView?> {
    get
  }
  public var didEndZooming: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.EndZoomEvent> {
    get
  }
  public func setDelegate(_ delegate: any UIKit.UIScrollViewDelegate) -> any OndatoSDK.Disposable
}
extension OndatoSDK.Reactive where Base : UIKit.UIGestureRecognizer {
  public var event: OndatoSDK.ControlEvent<Base> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIButton {
  public var tap: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIButton {
  public func title(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<Swift.String?>
  public func image(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<UIKit.UIImage?>
  public func backgroundImage(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<UIKit.UIImage?>
}
extension OndatoSDK.Reactive where Base : UIKit.UIButton {
  public func attributedTitle(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<Foundation.NSAttributedString?>
}
@_Concurrency.MainActor @preconcurrency open class RxTableViewDelegateProxy : OndatoSDK.RxScrollViewDelegateProxy {
  @_Concurrency.MainActor @preconcurrency weak public var tableView: UIKit.UITableView? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public init(tableView: UIKit.UITableView)
  @objc deinit
}
extension OndatoSDK.RxTableViewDelegateProxy : UIKit.UITableViewDelegate {
}
extension OndatoSDK.ObservableConvertibleType {
  public func asInfallible(onErrorJustReturn element: Self.Element) -> OndatoSDK.Infallible<Self.Element>
  public func asInfallible(onErrorFallbackTo infallible: OndatoSDK.Infallible<Self.Element>) -> OndatoSDK.Infallible<Self.Element>
  public func asInfallible(onErrorRecover: @escaping (any Swift.Error) -> OndatoSDK.Infallible<Self.Element>) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UINavigationController {
  public typealias ShowEvent = (viewController: UIKit.UIViewController, animated: Swift.Bool)
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UINavigationController, any UIKit.UINavigationControllerDelegate> {
    get
  }
  public var willShow: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.ShowEvent> {
    get
  }
  public var didShow: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.ShowEvent> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UISearchBar {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UISearchBar, any UIKit.UISearchBarDelegate> {
    get
  }
  public var text: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var selectedScopeButtonIndex: OndatoSDK.ControlProperty<Swift.Int> {
    get
  }
  public var cancelButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var bookmarkButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var resultsListButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var searchButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var textDidBeginEditing: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var textDidEndEditing: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public func setDelegate(_ delegate: any UIKit.UISearchBarDelegate) -> any OndatoSDK.Disposable
}
public enum RxCocoaURLError : Swift.Error {
  case unknown
  case nonHTTPResponse(response: Foundation.URLResponse)
  case httpRequestFailed(response: Foundation.HTTPURLResponse, data: Foundation.Data?)
  case deserializationError(error: any Swift.Error)
}
extension OndatoSDK.RxCocoaURLError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.Reactive where Base : Foundation.URLSession {
  public func response(request: Foundation.URLRequest) -> OndatoSDK.Observable<(response: Foundation.HTTPURLResponse, data: Foundation.Data)>
  public func data(request: Foundation.URLRequest) -> OndatoSDK.Observable<Foundation.Data>
  public func json(request: Foundation.URLRequest, options: Foundation.JSONSerialization.ReadingOptions = []) -> OndatoSDK.Observable<Any>
  public func json(url: Foundation.URL) -> OndatoSDK.Observable<Any>
}
extension OndatoSDK.Reactive where Base == Foundation.URLSession {
  public static var shouldLogRequest: (Foundation.URLRequest) -> Swift.Bool
}
extension OndatoSDK.Disposables {
  public static func create(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable) -> any OndatoSDK.Cancelable
}
extension OndatoSDK.ObservableType {
  public func delaySubscription(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
public enum CompletableTrait {
}
public typealias Completable = OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
@frozen public enum CompletableEvent {
  case error(any Swift.Error)
  case completed
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public typealias CompletableObserver = (OndatoSDK.CompletableEvent) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.CompletableObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (OndatoSDK.CompletableEvent) -> Swift.Void) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onCompleted: ((Object) -> Swift.Void)? = nil, onError: ((Object, any Swift.Error) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onCompleted: (() -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Completable
  public static func never() -> OndatoSDK.Completable
  public static func empty() -> OndatoSDK.Completable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public func `do`(onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Completable
  public func concat(_ second: OndatoSDK.Completable) -> OndatoSDK.Completable
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.Completable where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.Completable where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
  public static func concat(_ sources: OndatoSDK.Completable...) -> OndatoSDK.Completable
  public static func zip<Collection>(_ sources: Collection) -> OndatoSDK.Completable where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
  public static func zip(_ sources: [OndatoSDK.Completable]) -> OndatoSDK.Completable
  public static func zip(_ sources: OndatoSDK.Completable...) -> OndatoSDK.Completable
}
@_hasMissingDesignatedInitializers public class CurrentThreadScheduler : OndatoSDK.ImmediateSchedulerType {
  public static let instance: OndatoSDK.CurrentThreadScheduler
  public static var isScheduleRequired: Swift.Bool {
    get
  }
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func ifEmpty(switchTo other: OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UISegmentedControl {
  public var selectedSegmentIndex: OndatoSDK.ControlProperty<Swift.Int> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.Int> {
    get
  }
  public func enabledForSegment(at index: Swift.Int) -> OndatoSDK.Binder<Swift.Bool>
  public func titleForSegment(at index: Swift.Int) -> OndatoSDK.Binder<Swift.String?>
  public func imageForSegment(at index: Swift.Int) -> OndatoSDK.Binder<UIKit.UIImage?>
}
extension OndatoSDK.ObservableType {
  public func groupBy<Key>(keySelector: @escaping (Self.Element) throws -> Key) -> OndatoSDK.Observable<OndatoSDK.GroupedObservable<Key, Self.Element>> where Key : Swift.Hashable
}
public protocol ControlPropertyType : OndatoSDK.ObservableType, OndatoSDK.ObserverType {
  func asControlProperty() -> OndatoSDK.ControlProperty<Self.Element>
}
public struct ControlProperty<PropertyType> : OndatoSDK.ControlPropertyType {
  public typealias Element = PropertyType
  public init<Values, Sink>(values: Values, valueSink: Sink) where PropertyType == Values.Element, Values : OndatoSDK.ObservableType, Sink : OndatoSDK.ObserverType, Values.Element == Sink.Element
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where PropertyType == Observer.Element, Observer : OndatoSDK.ObserverType
  public var changed: OndatoSDK.ControlEvent<PropertyType> {
    get
  }
  public func asObservable() -> OndatoSDK.Observable<OndatoSDK.ControlProperty<PropertyType>.Element>
  public func asControlProperty() -> OndatoSDK.ControlProperty<OndatoSDK.ControlProperty<PropertyType>.Element>
  public func on(_ event: OndatoSDK.Event<OndatoSDK.ControlProperty<PropertyType>.Element>)
}
extension OndatoSDK.ControlPropertyType where Self.Element == Swift.String? {
  public var orEmpty: OndatoSDK.ControlProperty<Swift.String> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIActivityIndicatorView {
  public var isAnimating: OndatoSDK.Binder<Swift.Bool> {
    get
  }
}
public protocol ConnectableObservableType : OndatoSDK.ObservableType {
  func connect() -> any OndatoSDK.Disposable
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> OndatoSDK.Observable<Element?>
  public func observe<Element>(_ keyPath: Swift.KeyPath<Base, Element>, options: Foundation.NSKeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element?>
}
extension OndatoSDK.Reactive where Base : AnyObject {
  public var deallocated: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public func sentMessage(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  public func methodInvoked(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  public var deallocating: OndatoSDK.Observable<()> {
    get
  }
}
final public class BehaviorRelay<Element> : OndatoSDK.ObservableType {
  final public func accept(_ event: Element)
  final public var value: Element {
    get
  }
  public init(value: Element)
  final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
extension OndatoSDK.PublishRelay {
  final public func asSignal() -> OndatoSDK.Signal<Element>
}
@_hasMissingDesignatedInitializers public class DisposeBase {
  @objc deinit
}
public enum RxCocoaInterceptionMechanism {
  case unknown
  case kvo
  public static func == (a: OndatoSDK.RxCocoaInterceptionMechanism, b: OndatoSDK.RxCocoaInterceptionMechanism) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum RxCocoaObjCRuntimeError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown(target: Swift.AnyObject)
  case objectMessagesAlreadyBeingIntercepted(target: Swift.AnyObject, interceptionMechanism: OndatoSDK.RxCocoaInterceptionMechanism)
  case selectorNotImplemented(target: Swift.AnyObject)
  case cantInterceptCoreFoundationTollFreeBridgedObjects(target: Swift.AnyObject)
  case threadingCollisionWithOtherInterceptionMechanism(target: Swift.AnyObject)
  case savingOriginalForwardingMethodFailed(target: Swift.AnyObject)
  case replacingMethodWithForwardingImplementation(target: Swift.AnyObject)
  case observingPerformanceSensitiveMessages(target: Swift.AnyObject)
  case observingMessagesWithUnsupportedReturnType(target: Swift.AnyObject)
}
extension OndatoSDK.RxCocoaObjCRuntimeError {
  public var debugDescription: Swift.String {
    get
  }
}
public typealias RxAbstractInteger = Swift.FixedWidthInteger
extension OndatoSDK.ObservableType {
  public static func empty() -> OndatoSDK.Observable<Self.Element>
}
final public class PublishRelay<Element> : OndatoSDK.ObservableType {
  final public func accept(_ event: Element)
  public init()
  final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(Ondato) public class Ondato : ObjectiveC.NSObject {
  @objc public static let sdk: OndatoSDK.Ondato
  @objc weak public var delegate: (any OndatoSDK.OndatoFlowDelegate)?
  @objc public var configuration: OndatoSDK.OndatoServiceConfiguration
  @objc public func setIdentityVerificationId(_ id: Swift.String)
  @objc public func setSetupId(_ setupId: Swift.String)
  @objc public func setClientId(_ clientId: Swift.String)
  @objc public func setClientSecret(_ clientSecret: Swift.String)
  @objc public func instantiateOndatoViewController() -> OndatoSDK.OndatoViewController
  @objc deinit
}
extension UIKit.UIColor {
  public var lottieColorValue: OndatoSDK.Color {
    get
  }
}
public protocol AnimationImageProvider {
  func imageForAsset(asset: OndatoSDK.ImageAsset) -> CoreGraphics.CGImage?
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedSwitch : OndatoSDK.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: OndatoSDK.Animation)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: OndatoSDK.AnimatedSwitch.CancelBehavior, b: OndatoSDK.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var cancelBehavior: OndatoSDK.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor @preconcurrency public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func setProgressForState(fromProgress: OndatoSDK.AnimationProgressTime, toProgress: OndatoSDK.AnimationProgressTime, forOnState: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency override public func animationDidSet()
  @objc deinit
}
public protocol AnimationCacheProvider {
  func animation(forKey: Swift.String) -> OndatoSDK.Animation?
  func setAnimation(_ animation: OndatoSDK.Animation, forKey: Swift.String)
  func clearCache()
}
public typealias ParsedResult = OndatoSDK.MRZResult
public struct MRZParser {
  public init(isOCRCorrectionEnabled: Swift.Bool)
  public func parse(mrzLines: [Swift.String]) -> OndatoSDK.MRZResult?
  public func parse(mrzString: Swift.String) -> OndatoSDK.MRZResult?
}
final public class PointValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  public static func == (a: OndatoSDK.LottieBackgroundBehavior, b: OndatoSDK.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
}
extension OndatoSDK.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: OndatoSDK.LottieLoopMode, rhs: OndatoSDK.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency final public class AnimationView : OndatoSDK.LottieView {
  @_Concurrency.MainActor @preconcurrency public init(animation: OndatoSDK.Animation?, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, textProvider: any OndatoSDK.AnimationTextProvider = DefaultTextProvider(), fontProvider: any OndatoSDK.AnimationFontProvider = DefaultFontProvider())
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame _: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency final public var backgroundBehavior: OndatoSDK.LottieBackgroundBehavior
  @_Concurrency.MainActor @preconcurrency final public var animation: OndatoSDK.Animation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var imageProvider: any OndatoSDK.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var textProvider: any OndatoSDK.AnimationTextProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var fontProvider: any OndatoSDK.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var loopMode: OndatoSDK.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentProgress: OndatoSDK.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var currentFrame: OndatoSDK.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: OndatoSDK.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: OndatoSDK.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency final public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency final public func play(completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: OndatoSDK.AnimationProgressTime? = nil, toProgress: OndatoSDK.AnimationProgressTime, loopMode: OndatoSDK.LottieLoopMode? = nil, completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: OndatoSDK.AnimationFrameTime? = nil, toFrame: OndatoSDK.AnimationFrameTime, loopMode: OndatoSDK.LottieLoopMode? = nil, completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, loopMode: OndatoSDK.LottieLoopMode? = nil, completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency final public func stop()
  @_Concurrency.MainActor @preconcurrency final public func pause()
  @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @_Concurrency.MainActor @preconcurrency final public func setValueProvider(_ valueProvider: any OndatoSDK.AnyValueProvider, keypath: OndatoSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: OndatoSDK.AnimationKeypath, atFrame: OndatoSDK.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: OndatoSDK.AnimationSubview, forLayerAt keypath: OndatoSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency final public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: OndatoSDK.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor @preconcurrency final public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: OndatoSDK.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor @preconcurrency final public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: OndatoSDK.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> OndatoSDK.AnimationProgressTime?
  @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> OndatoSDK.AnimationFrameTime?
  @objc deinit
}
final public class GradientValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.GradientValueProvider.ColorsValueBlock, locations: OndatoSDK.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [OndatoSDK.Color], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [OndatoSDK.Color]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [OndatoSDK.Color] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(OndatoAppearance) public class OndatoAppearance : ObjectiveC.NSObject {
  @objc public var consentWindow: OndatoSDK.OndatoConsentAppearance
  @objc public var progressColor: UIKit.UIColor
  @objc public var errorColor: UIKit.UIColor
  @objc public var errorTextColor: UIKit.UIColor
  @objc public var buttonColor: UIKit.UIColor
  @objc public var buttonTextColor: UIKit.UIColor
  @objc public var textColor: UIKit.UIColor
  @objc public var backgroundColor: UIKit.UIColor
  @objc public var imageTintColor: UIKit.UIColor
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(OndatoGDRPAppearance) public class OndatoConsentAppearance : ObjectiveC.NSObject {
  @objc public var header: OndatoSDK.OndatoLabelAppearance
  @objc public var body: OndatoSDK.OndatoTextViewAppearance
  @objc public var acceptButton: OndatoSDK.OndatoButtonAppearance
  @objc public var declineButton: OndatoSDK.OndatoButtonAppearance
  @objc override dynamic public init()
  @objc deinit
}
@objc(OndatoButtonAppearance) public class OndatoButtonAppearance : ObjectiveC.NSObject {
  @objc public var font: UIKit.UIFont
  @objc public var backgroundColor: UIKit.UIColor
  @objc public var tintColor: UIKit.UIColor
  @objc public var borderWidth: CoreFoundation.CGFloat
  @objc public var borderColor: UIKit.UIColor
  @objc public var cornerRadius: CoreFoundation.CGFloat
  public init(font: UIKit.UIFont = .systemFont(ofSize: 15), backgroundColor: UIKit.UIColor = .clear, tintColor: UIKit.UIColor = .systemBlue, borderWidth: CoreFoundation.CGFloat = 0, borderColor: UIKit.UIColor = .clear, cornerRadius: CoreFoundation.CGFloat = 0)
  @objc deinit
}
@objc(OndatoLabelAppearance) public class OndatoLabelAppearance : ObjectiveC.NSObject {
  @objc public var font: UIKit.UIFont
  @objc public var color: UIKit.UIColor
  public init(font: UIKit.UIFont = .systemFont(ofSize: 15, weight: .semibold), color: UIKit.UIColor = .black)
  @objc deinit
}
@objc(OndatoTextViewAppearance) public class OndatoTextViewAppearance : ObjectiveC.NSObject {
  @objc public var font: UIKit.UIFont
  @objc public var textColor: UIKit.UIColor
  public init(font: UIKit.UIFont = .systemFont(ofSize: 15), textColor: UIKit.UIColor = .black)
  @objc deinit
}
extension OndatoSDK.Vector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.Vector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.Vector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
public enum CoordinateSpace : Swift.Int, Swift.Codable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class Animation : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let startFrame: OndatoSDK.AnimationFrameTime
  final public let endFrame: OndatoSDK.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(OndatoLogManager) public class OndatoLogManager : ObjectiveC.NSObject {
  @objc public static let manager: OndatoSDK.OndatoLogManager
  @objc public func showLogButton()
  @objc public func hideLogButton()
  @objc deinit
}
final public class SizeValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
public struct ImageMRZScanner {
  public init()
  public func scan(scanningImage: OndatoSDK.ScanningImage, orientation: ImageIO.CGImagePropertyOrientation, regionOfInterest: CoreFoundation.CGRect? = nil, minimumTextHeight: Swift.Float? = nil, recognitionLevel: OndatoSDK.RecognitionLevel = .accurate, foundBoundingRectsHandler: (([CoreFoundation.CGRect]) -> Swift.Void)? = nil, completionHandler: @escaping (Swift.Result<OndatoSDK.DocumentScanningResult<OndatoSDK.ParsedResult>, any Swift.Error>) -> Swift.Void)
}
final public class FloatValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  func hasUpdate(frame: OndatoSDK.AnimationFrameTime) -> Swift.Bool
  func value(frame: OndatoSDK.AnimationFrameTime) -> Any
}
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : OndatoSDK.AnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
@objc(OndatoSupportedLanguage) public enum OndatoSupportedLanguage : Swift.Int, Swift.RawRepresentable {
  case BG
  case DE
  case EN
  case ES
  case ET
  case FR
  case EL
  case IT
  case LT
  case LV
  case NL
  case RO
  case RU
  case SQ
  public typealias RawValue = Swift.String
  public var rawValue: OndatoSDK.OndatoSupportedLanguage.RawValue {
    get
  }
  public var displayName: Swift.String {
    get
  }
  public init?(rawValue: OndatoSDK.OndatoSupportedLanguage.RawValue)
}
extension OndatoSDK.OndatoSupportedLanguage : Swift.CaseIterable {
  public typealias AllCases = [OndatoSDK.OndatoSupportedLanguage]
  nonisolated public static var allCases: [OndatoSDK.OndatoSupportedLanguage] {
    get
  }
}
public enum ColorFormatDenominator {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: OndatoSDK.ColorFormatDenominator, b: OndatoSDK.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Color {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: OndatoSDK.ColorFormatDenominator = .One)
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
public class BundleImageProvider : OndatoSDK.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?)
  public func imageForAsset(asset: OndatoSDK.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
extension OndatoSDK.AnimationView {
  @_Concurrency.MainActor @preconcurrency convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, animationCache: (any OndatoSDK.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor @preconcurrency convenience public init(filePath: Swift.String, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, animationCache: (any OndatoSDK.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, closure: @escaping OndatoSDK.AnimationView.DownloadClosure, animationCache: (any OndatoSDK.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
public enum MRZFormat : Swift.CaseIterable {
  case td1, td2, td3
  public var lineLength: Swift.Int {
    get
  }
  public var linesCount: Swift.Int {
    get
  }
  public static func == (a: OndatoSDK.MRZFormat, b: OndatoSDK.MRZFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [OndatoSDK.MRZFormat]
  nonisolated public static var allCases: [OndatoSDK.MRZFormat] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct MRZResult : Swift.Hashable {
  public enum DocumentType : Swift.CaseIterable {
    case visa
    case passport
    case id
    case residencePermit
    case undefined
    public static func == (a: OndatoSDK.MRZResult.DocumentType, b: OndatoSDK.MRZResult.DocumentType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [OndatoSDK.MRZResult.DocumentType]
    nonisolated public static var allCases: [OndatoSDK.MRZResult.DocumentType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Sex : Swift.CaseIterable {
    case male
    case female
    case unspecified
    public static func == (a: OndatoSDK.MRZResult.Sex, b: OndatoSDK.MRZResult.Sex) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [OndatoSDK.MRZResult.Sex]
    nonisolated public static var allCases: [OndatoSDK.MRZResult.Sex] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public let format: OndatoSDK.MRZFormat
  public let documentType: OndatoSDK.MRZResult.DocumentType
  public let countryCode: Swift.String
  public let surnames: Swift.String
  public let givenNames: Swift.String
  public let documentNumber: Swift.String?
  public let nationalityCountryCode: Swift.String
  public let birthdate: Foundation.Date?
  public let sex: OndatoSDK.MRZResult.Sex
  public let expiryDate: Foundation.Date?
  public let optionalData: Swift.String?
  public let optionalData2: Swift.String?
  public var documentImage: UIKit.UIImage?
  public init(format: OndatoSDK.MRZFormat, documentType: OndatoSDK.MRZResult.DocumentType, countryCode: Swift.String, surnames: Swift.String, givenNames: Swift.String, documentNumber: Swift.String?, nationalityCountryCode: Swift.String, birthdate: Foundation.Date?, sex: OndatoSDK.MRZResult.Sex, expiryDate: Foundation.Date?, optionalData: Swift.String?, optionalData2: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OndatoSDK.MRZResult, b: OndatoSDK.MRZResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
public enum AnyValue {
  case double(Swift.Double?)
  case int(Swift.Int?)
  case uint64(Swift.UInt64?)
  case string(Swift.String?)
  case bool(Swift.Bool?)
  case object((any Swift.Encodable)?)
  case null
  indirect case array([OndatoSDK.AnyValue]?)
  indirect case dictionary([Swift.String : OndatoSDK.AnyValue]?)
}
extension OndatoSDK.AnyValue : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByNilLiteral {
  public init(nilLiteral: ())
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public init(_ string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = OndatoSDK.AnyValue
  public init(arrayLiteral elements: OndatoSDK.AnyValue...)
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.String
  public typealias Value = OndatoSDK.AnyValue
  public init(dictionaryLiteral elements: (Swift.String, OndatoSDK.AnyValue)...)
}
extension Swift.Dictionary where Key == Swift.String, Value == OndatoSDK.AnyValue {
  public func toStringKeyAndRemoveNilObjects() -> [Swift.String : OndatoSDK.AnyValue]
}
extension OndatoSDK.Color : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedButton : OndatoSDK.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: OndatoSDK.Animation)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromProgress: OndatoSDK.AnimationProgressTime, toProgress: OndatoSDK.AnimationProgressTime, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class LiveMRZScanner {
  public init(frequency: Swift.Int = 2)
  final public func scanFrame(scanningImage: OndatoSDK.ScanningImage, orientation: ImageIO.CGImagePropertyOrientation, regionOfInterest: CoreFoundation.CGRect? = nil, minimumTextHeight: Swift.Float? = nil, foundBoundingRectsHandler: (([CoreFoundation.CGRect]) -> Swift.Void)? = nil, completionHandler: @escaping (Swift.Result<OndatoSDK.DocumentScanningResult<OndatoSDK.ParsedResult>, any Swift.Error>) -> Swift.Void)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : OndatoSDK.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public typealias ScannedBoundingRects = (valid: [CoreFoundation.CGRect], invalid: [CoreFoundation.CGRect])
public struct DocumentScanningResult<T> {
  public let result: T
  public let boundingRects: OndatoSDK.ScannedBoundingRects
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class OndatoLog : ObjectiveC.NSObject {
  public static let shared: OndatoSDK.OndatoLog
  public var logs: [Swift.String] {
    get
  }
  @objc deinit
}
public class LRUAnimationCache : OndatoSDK.AnimationCacheProvider {
  public init()
  public static let sharedCache: OndatoSDK.LRUAnimationCache
  public var cacheSize: Swift.Int
  public func clearCache()
  public func animation(forKey: Swift.String) -> OndatoSDK.Animation?
  public func setAnimation(_ animation: OndatoSDK.Animation, forKey: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor @preconcurrency public class OndatoViewController : UIKit.UIPageViewController {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(transitionStyle style: UIKit.UIPageViewController.TransitionStyle, navigationOrientation: UIKit.UIPageViewController.NavigationOrientation, options: [UIKit.UIPageViewController.OptionsKey : Any]? = nil)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc(OndatoServerMode) public enum OndatoEnvironment : Swift.Int {
  case test = 0
  case live = 1
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class FilepathImageProvider : OndatoSDK.AnimationImageProvider {
  public init(filepath: Swift.String)
  public init(filepath: Foundation.URL)
  public func imageForAsset(asset: OndatoSDK.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public static let modelName: Swift.String
  @_Concurrency.MainActor @preconcurrency public static let osVersion: OndatoSDK.OSVersion
}
extension Swift.Encodable {
  public var jsonData: Foundation.Data? {
    get
  }
}
public struct Vector1D {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
}
public struct Vector3D {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: OndatoSDK.AnimationKeypath
  @objc deinit
}
extension UIKit.UIImage {
  public class func gifImageWithData(_ data: Foundation.Data) -> UIKit.UIImage?
  public class func gifImageWithURL(_ gifUrl: Swift.String) -> UIKit.UIImage?
  public class func gifImageWithName(_ name: Swift.String) -> UIKit.UIImage?
}
public enum RecognitionLevel {
  case accurate
  case fast
  public static func == (a: OndatoSDK.RecognitionLevel, b: OndatoSDK.RecognitionLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct OSVersion : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
@objc(OndatoFlowDelegate) public protocol OndatoFlowDelegate {
  @objc optional func viewControllerForStart(startPressed: @escaping () -> Swift.Void) -> UIKit.UIViewController
  @objc optional func viewForLoading(progress: Swift.Float) -> UIKit.UIView?
  @objc optional func viewForSuccess(continue: @escaping () -> Swift.Void) -> UIKit.UIView
  @objc func flowDidSucceed(identificationId: Swift.String?)
  @objc func flowDidFail(identificationId: Swift.String?, error: OndatoSDK.OndatoServiceError)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(OndatoServiceConfiguration) public class OndatoServiceConfiguration : ObjectiveC.NSObject {
  @objc public var appearance: OndatoSDK.OndatoAppearance
  @objc public var flowConfiguration: OndatoSDK.OndatoFlowConfiguration
  @objc public var mode: OndatoSDK.OndatoEnvironment
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(OndatoFlowConfiguration) public class OndatoFlowConfiguration : ObjectiveC.NSObject {
  @objc public var showStartScreen: Swift.Bool
  @objc public var showSuccessWindow: Swift.Bool
  @objc public var removeSelfieFrame: Swift.Bool
  @objc public var skipRegistrationIfDriverLicense: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class LottieView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public typealias LottieCompletionBlock = (Swift.Bool) -> Swift.Void
@objc(OndatoDocumentType) public enum OndatoDocumentType : Swift.Int, Swift.Codable {
  case passport = 0
  case idCard = 1
  case drivingLicence = 2
  case proofOfAddress = 3
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(OndatoLocalizeHelper) public class OndatoLocalizeHelper : ObjectiveC.NSObject {
  @objc public static let shared: OndatoSDK.OndatoLocalizeHelper
  @objc public var language: OndatoSDK.OndatoSupportedLanguage
  @objc public func setLocalizationBundle(_ bundle: OndatoSDK.OndatoLocalizationBundle, for language: OndatoSDK.OndatoSupportedLanguage)
  @objc deinit
}
public struct AnimationKeypath {
  public init(keypath: Swift.String)
  public init(keys: [Swift.String])
}
final public class ColorValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.ColorValueProvider.ColorValueBlock)
  public init(_ color: OndatoSDK.Color)
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> OndatoSDK.Color
  final public var color: OndatoSDK.Color {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
public enum ScanningImage {
  case cgImage(CoreGraphics.CGImage)
  case pixelBuffer(CoreVideo.CVPixelBuffer)
}
extension OndatoSDK.OndatoServiceError.OndatoServiceErrorType : Swift.Equatable {}
extension OndatoSDK.OndatoServiceError.OndatoServiceErrorType : Swift.Hashable {}
extension OndatoSDK.OndatoServiceError.OndatoServiceErrorType : Swift.RawRepresentable {}
extension OndatoSDK.LayerType : Swift.Equatable {}
extension OndatoSDK.LayerType : Swift.Hashable {}
extension OndatoSDK.LayerType : Swift.RawRepresentable {}
extension OndatoSDK.MatteType : Swift.Equatable {}
extension OndatoSDK.MatteType : Swift.Hashable {}
extension OndatoSDK.MatteType : Swift.RawRepresentable {}
extension OndatoSDK.BlendMode : Swift.Equatable {}
extension OndatoSDK.BlendMode : Swift.Hashable {}
extension OndatoSDK.BlendMode : Swift.RawRepresentable {}
extension OndatoSDK.TakeBehavior : Swift.Equatable {}
extension OndatoSDK.TakeBehavior : Swift.Hashable {}
extension OndatoSDK.RxCollectionViewDelegateProxy : Swift.Sendable {}
extension OndatoSDK.SubjectLifetimeScope : Swift.Equatable {}
extension OndatoSDK.SubjectLifetimeScope : Swift.Hashable {}
extension OndatoSDK.RxTextViewDelegateProxy : Swift.Sendable {}
extension OndatoSDK.VirtualTimeComparison : Swift.Equatable {}
extension OndatoSDK.VirtualTimeComparison : Swift.Hashable {}
extension OndatoSDK.RxTableViewDelegateProxy : Swift.Sendable {}
extension OndatoSDK.CompletableEvent : Swift.Sendable {}
extension OndatoSDK.RxCocoaInterceptionMechanism : Swift.Equatable {}
extension OndatoSDK.RxCocoaInterceptionMechanism : Swift.Hashable {}
extension OndatoSDK.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension OndatoSDK.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension OndatoSDK.LottieBackgroundBehavior : Swift.Equatable {}
extension OndatoSDK.LottieBackgroundBehavior : Swift.Hashable {}
extension OndatoSDK.CoordinateSpace : Swift.Equatable {}
extension OndatoSDK.CoordinateSpace : Swift.Hashable {}
extension OndatoSDK.CoordinateSpace : Swift.RawRepresentable {}
extension OndatoSDK.OndatoSupportedLanguage : Swift.Equatable {}
extension OndatoSDK.OndatoSupportedLanguage : Swift.Hashable {}
extension OndatoSDK.ColorFormatDenominator : Swift.Equatable {}
extension OndatoSDK.ColorFormatDenominator : Swift.Hashable {}
extension OndatoSDK.MRZFormat : Swift.Equatable {}
extension OndatoSDK.MRZFormat : Swift.Hashable {}
extension OndatoSDK.MRZResult.DocumentType : Swift.Equatable {}
extension OndatoSDK.MRZResult.DocumentType : Swift.Hashable {}
extension OndatoSDK.MRZResult.Sex : Swift.Equatable {}
extension OndatoSDK.MRZResult.Sex : Swift.Hashable {}
extension OndatoSDK.OndatoEnvironment : Swift.Equatable {}
extension OndatoSDK.OndatoEnvironment : Swift.Hashable {}
extension OndatoSDK.OndatoEnvironment : Swift.RawRepresentable {}
extension OndatoSDK.RecognitionLevel : Swift.Equatable {}
extension OndatoSDK.RecognitionLevel : Swift.Hashable {}
extension OndatoSDK.OndatoDocumentType : Swift.Equatable {}
extension OndatoSDK.OndatoDocumentType : Swift.Hashable {}
extension OndatoSDK.OndatoDocumentType : Swift.RawRepresentable {}
