// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name OndatoSDK
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreLocation
import CoreNFC
import CoreServices
import CoreText
import CryptoKit
import CryptoTokenKit
import Darwin
import Dispatch
import FaceTecSDK
import Foundation
import ImageIO
import MobileCoreServices
@_exported import OndatoSDK
import OpenSSL
import Photos
import QuartzCore
import ReplayKit
import Swift
import UIKit
import Vision
import WebKit
import _Concurrency
import _StringProcessing
extension OndatoSDK.Reactive where Base : UIKit.UIScrollView {
  public typealias EndZoomEvent = (view: UIKit.UIView?, scale: CoreFoundation.CGFloat)
  public typealias WillEndDraggingEvent = (velocity: CoreFoundation.CGPoint, targetContentOffset: Swift.UnsafeMutablePointer<CoreFoundation.CGPoint>)
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UIScrollView, any UIKit.UIScrollViewDelegate> {
    get
  }
  public var contentOffset: OndatoSDK.ControlProperty<CoreFoundation.CGPoint> {
    get
  }
  public var didScroll: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginDecelerating: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var didEndDecelerating: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginDragging: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willEndDragging: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.WillEndDraggingEvent> {
    get
  }
  public var didEndDragging: OndatoSDK.ControlEvent<Swift.Bool> {
    get
  }
  public var didZoom: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var didScrollToTop: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var didEndScrollingAnimation: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var willBeginZooming: OndatoSDK.ControlEvent<UIKit.UIView?> {
    get
  }
  public var didEndZooming: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.EndZoomEvent> {
    get
  }
  public func setDelegate(_ delegate: any UIKit.UIScrollViewDelegate) -> any OndatoSDK.Disposable
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ReplaySubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.ObserverType, OndatoSDK.Disposable {
  public typealias SubjectObserverType = OndatoSDK.ReplaySubject<Element>
  public var hasObservers: Swift.Bool {
    get
  }
  public func on(_ event: OndatoSDK.Event<Element>)
  public func asObserver() -> OndatoSDK.ReplaySubject<Element>
  public func dispose()
  public static func create(bufferSize: Swift.Int) -> OndatoSDK.ReplaySubject<Element>
  public static func createUnbounded() -> OndatoSDK.ReplaySubject<Element>
  public typealias Observer = OndatoSDK.ReplaySubject<Element>
  @objc deinit
}
public enum CompletableTrait {
}
public typealias Completable = OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
@frozen public enum CompletableEvent {
  case error(any Swift.Error)
  case completed
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public typealias CompletableObserver = (OndatoSDK.CompletableEvent) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.CompletableObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (OndatoSDK.CompletableEvent) -> Swift.Void) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onCompleted: ((Object) -> Swift.Void)? = nil, onError: ((Object, any Swift.Error) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onCompleted: (() -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Completable
  public static func never() -> OndatoSDK.Completable
  public static func empty() -> OndatoSDK.Completable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public func `do`(onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Completable
  public func concat(_ second: OndatoSDK.Completable) -> OndatoSDK.Completable
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.Completable where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.Completable where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
  public static func concat(_ sources: OndatoSDK.Completable...) -> OndatoSDK.Completable
  public static func zip<Collection>(_ sources: Collection) -> OndatoSDK.Completable where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.CompletableTrait, Swift.Never>
  public static func zip(_ sources: [OndatoSDK.Completable]) -> OndatoSDK.Completable
  public static func zip(_ sources: OndatoSDK.Completable...) -> OndatoSDK.Completable
}
@_hasMissingDesignatedInitializers @objc(OndatoServiceError) public class OndatoServiceError : ObjectiveC.NSObject {
  @objc(OndatoServiceErrorType) public enum OndatoServiceErrorType : Swift.Int {
    case cancelled
    case consentDenied
    case invalidServerResponse
    case invalidCredentials
    case recorderPermissions
    case unexpectedInternalError
    case verificationFailed
    case nfcNotSupported
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  final public let type: OndatoSDK.OndatoServiceError.OndatoServiceErrorType
  final public let error: Swift.String?
  final public let message: Swift.String?
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UITableView {
  public func items<Sequence, Source>(_ source: Source) -> (_ cellFactory: @escaping (UIKit.UITableView, Swift.Int, Sequence.Element) -> UIKit.UITableViewCell) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Sequence, Cell, Source>(cellIdentifier: Swift.String, cellType: Cell.Type = Cell.self) -> (_ source: Source) -> (_ configureCell: @escaping (Swift.Int, Sequence.Element, Cell) -> Swift.Void) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Cell : UIKit.UITableViewCell, Source : OndatoSDK.ObservableType
  public func items<DataSource, Source>(dataSource: DataSource) -> (_ source: Source) -> any OndatoSDK.Disposable where DataSource : OndatoSDK.RxTableViewDataSourceType, DataSource : UIKit.UITableViewDataSource, Source : OndatoSDK.ObservableType, DataSource.Element == Source.Element
}
extension OndatoSDK.Reactive where Base : UIKit.UITableView {
  public var dataSource: OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSource> {
    get
  }
  public func setDataSource(_ dataSource: any UIKit.UITableViewDataSource) -> any OndatoSDK.Disposable
  public var itemSelected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeselected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemHighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemUnhighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemAccessoryButtonTapped: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemInserted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeleted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemMoved: OndatoSDK.ControlEvent<OndatoSDK.ItemMovedEvent> {
    get
  }
  public var willDisplayCell: OndatoSDK.ControlEvent<OndatoSDK.WillDisplayCellEvent> {
    get
  }
  public var didEndDisplayingCell: OndatoSDK.ControlEvent<OndatoSDK.DidEndDisplayingCellEvent> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func modelDeselected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func modelDeleted<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.Reactive where Base : UIKit.UITableView {
  public var prefetchDataSource: OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSourcePrefetching> {
    get
  }
  public func setPrefetchDataSource(_ prefetchDataSource: any UIKit.UITableViewDataSourcePrefetching) -> any OndatoSDK.Disposable
  public var prefetchRows: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public var cancelPrefetchingForRows: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
}
public enum RxCocoaError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case invalidOperation(object: Any)
  case itemsNotYetBound(object: Any)
  case invalidPropertyName(object: Any, propertyName: Swift.String)
  case invalidObjectOnKeyPath(object: Any, sourceObject: Swift.AnyObject, propertyName: Swift.String)
  case errorDuringSwizzling
  case castingError(object: Any, targetType: any Any.Type)
}
extension OndatoSDK.RxCocoaError {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.ObservableType {
  public static func generate(initialState: Self.Element, condition: @escaping (Self.Element) throws -> Swift.Bool, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance, iterate: @escaping (Self.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element>
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateType {
  case documentSigningCertificate
  case issuerSigningCertificate
  public static func == (a: OndatoSDK.CertificateType, b: OndatoSDK.CertificateType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateItem : Swift.String {
  case fingerprint
  case issuerName
  case subjectName
  case serialNumber
  case signatureAlgorithm
  case publicKeyAlgorithm
  case notBefore
  case notAfter
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class X509Wrapper {
  final public let cert: Swift.OpaquePointer
  public init?(with cert: Swift.OpaquePointer?)
  public func getItemsAsDict() -> [OndatoSDK.CertificateItem : Swift.String]
  public func certToPEM() -> Swift.String
  public func getFingerprint() -> Swift.String?
  public func getNotBeforeDate() -> Swift.String?
  public func getNotAfterDate() -> Swift.String?
  public func getSerialNumber() -> Swift.String?
  public func getSignatureAlgorithm() -> Swift.String?
  public func getPublicKeyAlgorithm() -> Swift.String?
  public func getIssuerName() -> Swift.String?
  public func getSubjectName() -> Swift.String?
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func throttle(_ dueTime: OndatoSDK.RxTimeInterval, latest: Swift.Bool = true, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func map<Result>(_ selector: @escaping (Self.Element) -> Result) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Result>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func compactMap<Result>(_ selector: @escaping (Self.Element) -> Result?) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Result>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func filter(_ predicate: @escaping (Self.Element) -> Swift.Bool) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element : OndatoSDK.SharedSequenceConvertibleType {
  public func switchLatest() -> OndatoSDK.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func flatMapLatest<Sharing, Result>(_ selector: @escaping (Self.Element) -> OndatoSDK.SharedSequence<Sharing, Result>) -> OndatoSDK.SharedSequence<Sharing, Result> where Sharing : OndatoSDK.SharingStrategyProtocol
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func flatMapFirst<Sharing, Result>(_ selector: @escaping (Self.Element) -> OndatoSDK.SharedSequence<Sharing, Result>) -> OndatoSDK.SharedSequence<Sharing, Result> where Sharing : OndatoSDK.SharingStrategyProtocol
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func `do`(onNext: ((Self.Element) -> Swift.Void)? = nil, afterNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, afterCompleted: (() -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) -> Key) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) -> K, comparer: @escaping (K, K) -> Swift.Bool) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func flatMap<Sharing, Result>(_ selector: @escaping (Self.Element) -> OndatoSDK.SharedSequence<Sharing, Result>) -> OndatoSDK.SharedSequence<Sharing, Result> where Sharing : OndatoSDK.SharingStrategyProtocol
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public static func merge<Collection>(_ sources: Collection) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: [OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>]) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>...) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element : OndatoSDK.SharedSequenceConvertibleType {
  public func merge() -> OndatoSDK.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> OndatoSDK.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func throttle(_ dueTime: OndatoSDK.RxTimeInterval, latest: Swift.Bool = true) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
  public func debounce(_ dueTime: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) -> A) -> OndatoSDK.SharedSequence<Self.SharingStrategy, A>
}
extension OndatoSDK.SharedSequence {
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence {
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> OndatoSDK.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func zip<Collection>(_ collection: Collection) -> OndatoSDK.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> OndatoSDK.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func combineLatest<Collection>(_ collection: Collection) -> OndatoSDK.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.SignalSharingStrategy {
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Out> where Object : AnyObject
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (Object, Self.Element)> where Object : AnyObject
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.DriverSharingStrategy {
  @available(*, unavailable, message: "withUnretained has been deprecated for Driver. Consider using `drive(with:onNext:onCompleted:onDisposed:)`, instead")
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Out> where Object : AnyObject
  @available(*, unavailable, message: "withUnretained has been deprecated for Driver. Consider using `drive(with:onNext:onCompleted:onDisposed:)`, instead")
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (Object, Self.Element)> where Object : AnyObject
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func withLatestFrom<SecondO, ResultType>(_ second: SecondO, resultSelector: @escaping (Self.Element, SecondO.Element) -> ResultType) -> OndatoSDK.SharedSequence<Self.SharingStrategy, ResultType> where SecondO : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == SecondO.SharingStrategy
  public func withLatestFrom<SecondO>(_ second: SecondO) -> OndatoSDK.SharedSequence<Self.SharingStrategy, SecondO.Element> where SecondO : OndatoSDK.SharedSequenceConvertibleType
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func skip(_ count: Swift.Int) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func startWith(_ element: Self.Element) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func delay(_ dueTime: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
@available(iOS 13, macOS 10.15, *)
public enum DataGroupId : Swift.Int, Swift.CaseIterable {
  case COM
  case DG1
  case DG2
  case DG3
  case DG4
  case DG5
  case DG6
  case DG7
  case DG8
  case DG9
  case DG10
  case DG11
  case DG12
  case DG13
  case DG14
  case DG15
  case DG16
  case SOD
  case Unknown
  public func getName() -> Swift.String
  public static func getIDFromName(name: Swift.String) -> OndatoSDK.DataGroupId
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [OndatoSDK.DataGroupId]
  public typealias RawValue = Swift.Int
  public static var allCases: [OndatoSDK.DataGroupId] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOS 10.0, tvOS 10.0, *)
extension UIKit.UITableView : OndatoSDK.HasPrefetchDataSource {
  public typealias PrefetchDataSource = UIKit.UITableViewDataSourcePrefetching
}
@available(iOS 10.0, tvOS 10.0, *)
open class RxTableViewDataSourcePrefetchingProxy : OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSourcePrefetching>, OndatoSDK.DelegateProxyType {
  weak public var tableView: UIKit.UITableView? {
    get
  }
  public init(tableView: OndatoSDK.RxTableViewDataSourcePrefetchingProxy.ParentObject)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UITableViewDataSourcePrefetching)?, retainDelegate: Swift.Bool)
  @objc deinit
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.RxTableViewDataSourcePrefetchingProxy : UIKit.UITableViewDataSourcePrefetching {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, prefetchRowsAt indexPaths: [Foundation.IndexPath])
}
@objc(OndatoLocalizationBundle) public class OndatoLocalizationBundle : ObjectiveC.NSObject {
  @objc public static func bundle(with bundle: Foundation.Bundle, tableName: Swift.String) -> OndatoSDK.OndatoLocalizationBundle
  @objc public init(bundle: Foundation.Bundle, tableName: Swift.String)
  @objc deinit
}
final public class BooleanDisposable : OndatoSDK.Cancelable {
  public init()
  public init(isDisposed: Swift.Bool)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func toArray() -> OndatoSDK.Single<[Self.Element]>
}
@available(iOS 13, macOS 10.15, *)
public enum NFCViewDisplayMessage {
  case requestPresentPassport
  case authenticatingWithPassport(Swift.Int)
  case readingDataGroupProgress(OndatoSDK.DataGroupId, Swift.Int)
  case error(OndatoSDK.NFCPassportReaderError)
  case successfulRead
}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.NFCViewDisplayMessage {
  public var description: Swift.String {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func ifEmpty(default: Self.Element) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func range(start: Self.Element, count: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
}
@_hasMissingDesignatedInitializers final public class MainScheduler : OndatoSDK.SerialDispatchQueueScheduler {
  public init()
  public static let instance: OndatoSDK.MainScheduler
  public static let asyncInstance: OndatoSDK.SerialDispatchQueueScheduler
  public static func ensureExecutingOnScheduler(errorMessage: Swift.String? = nil)
  public static func ensureRunningOnMainThread(errorMessage: Swift.String? = nil)
  @objc deinit
}
public class ConcurrentDispatchQueueScheduler : OndatoSDK.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  public init(queue: Dispatch.DispatchQueue, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  convenience public init(qos: Dispatch.DispatchQoS, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
  @objc deinit
}
public protocol Disposable {
  func dispose()
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) public init(compatibleAnimation: OndatoSDK.CompatibleAnimation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor(unsafe) final public var compatibleAnimation: OndatoSDK.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public func play()
  @objc @_Concurrency.MainActor(unsafe) final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func stop()
  @objc @_Concurrency.MainActor(unsafe) final public func pause()
  @objc @_Concurrency.MainActor(unsafe) final public func reloadImages()
  @objc @_Concurrency.MainActor(unsafe) final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor(unsafe) final public func getValue(for keypath: OndatoSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor(unsafe) final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor(unsafe) final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: OndatoSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func getColorValue(for keypath: OndatoSDK.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor(unsafe) final public func addSubview(_ subview: OndatoSDK.AnimationSubview, forLayerAt keypath: OndatoSDK.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: OndatoSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor(unsafe) final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: OndatoSDK.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor(unsafe) final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func delaySubscription(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
public protocol AnimationTextProvider : AnyObject {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
final public class DictionaryTextProvider : OndatoSDK.AnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
final public class DefaultTextProvider : OndatoSDK.AnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension OndatoSDK.Animation {
  public typealias DownloadClosure = (OndatoSDK.Animation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any OndatoSDK.AnimationCacheProvider)? = nil) -> OndatoSDK.Animation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any OndatoSDK.AnimationCacheProvider)? = nil) -> OndatoSDK.Animation?
  public static func loadedFrom(url: Foundation.URL, closure: @escaping OndatoSDK.Animation.DownloadClosure, animationCache: (any OndatoSDK.AnimationCacheProvider)?)
  final public func progressTime(forMarker named: Swift.String) -> OndatoSDK.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> OndatoSDK.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: OndatoSDK.AnimationFrameTime) -> OndatoSDK.AnimationProgressTime
  final public func frameTime(forProgress progressTime: OndatoSDK.AnimationProgressTime) -> OndatoSDK.AnimationFrameTime
  final public func time(forFrame frameTime: OndatoSDK.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> OndatoSDK.AnimationFrameTime
}
extension UIKit.NSTextStorage : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.NSTextStorageDelegate
}
open class RxTextStorageDelegateProxy : OndatoSDK.DelegateProxy<UIKit.NSTextStorage, any UIKit.NSTextStorageDelegate>, OndatoSDK.DelegateProxyType {
  weak public var textStorage: UIKit.NSTextStorage? {
    get
  }
  public init(textStorage: UIKit.NSTextStorage)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxTextStorageDelegateProxy : UIKit.NSTextStorageDelegate {
}
public protocol Cancelable : OndatoSDK.Disposable {
  var isDisposed: Swift.Bool { get }
}
extension OndatoSDK.PublishRelay {
  final public func asSignal() -> OndatoSDK.Signal<Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UISlider {
  public var value: OndatoSDK.ControlProperty<Swift.Float> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public static func zip<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : OndatoSDK.ObservableType
  public static func zip<Collection>(_ collection: Collection) -> OndatoSDK.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : OndatoSDK.ObservableType
}
@objc @_Concurrency.MainActor(unsafe) open class AnimatedControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) public init(animation: OndatoSDK.Animation)
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) open func animationDidSet()
  @_Concurrency.MainActor(unsafe) final public let animationView: OndatoSDK.AnimationView
  @_Concurrency.MainActor(unsafe) public var animation: OndatoSDK.Animation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func setLayer(named: Swift.String, forState: UIKit.UIControl.State)
  @_Concurrency.MainActor(unsafe) public func setValueProvider(_ valueProvider: any OndatoSDK.AnyValueProvider, keypath: OndatoSDK.AnimationKeypath)
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func debounce(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIBarButtonItem {
  public var tap: OndatoSDK.ControlEvent<()> {
    get
  }
}
extension QuartzCore.CALayer {
  public func logLayerTree(withIndent: Swift.Int = 0)
}
open class VirtualTimeScheduler<Converter> : OndatoSDK.SchedulerType where Converter : OndatoSDK.VirtualTimeConverterType {
  public typealias VirtualTime = Converter.VirtualTimeUnit
  public typealias VirtualTimeInterval = Converter.VirtualTimeIntervalUnit
  public var now: OndatoSDK.RxTime {
    get
  }
  public var clock: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime {
    get
  }
  public init(initialClock: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime, converter: Converter)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func scheduleRelativeVirtual<StateType>(_ state: StateType, dueTime: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func scheduleAbsoluteVirtual<StateType>(_ state: StateType, time: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  open func adjustScheduledTime(_ time: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime) -> OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime
  public func start()
  public func advanceTo(_ virtualTime: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTime)
  public func sleep(_ virtualInterval: OndatoSDK.VirtualTimeScheduler<Converter>.VirtualTimeInterval)
  public func stop()
  @objc deinit
}
extension OndatoSDK.VirtualTimeScheduler : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> OndatoSDK.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : OndatoSDK.KVORepresentable
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : OndatoSDK.KVORepresentable
}
extension OndatoSDK.ObservableType {
  public func delay(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
final public class BehaviorRelay<Element> : OndatoSDK.ObservableType {
  final public func accept(_ event: Element)
  final public var value: Element {
    get
  }
  public init(value: Element)
  final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
public enum MaybeTrait {
}
public typealias Maybe<Element> = OndatoSDK.PrimitiveSequence<OndatoSDK.MaybeTrait, Element>
@frozen public enum MaybeEvent<Element> {
  case success(Element)
  case error(any Swift.Error)
  case completed
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public typealias MaybeObserver = (OndatoSDK.MaybeEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.MaybeObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  public func subscribe(_ observer: @escaping (OndatoSDK.MaybeEvent<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onSuccess: ((Object, Self.Element) -> Swift.Void)? = nil, onError: ((Object, any Swift.Error) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func just(_ element: Self.Element) -> OndatoSDK.Maybe<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Maybe<Self.Element>
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Maybe<Self.Element>
  public static func never() -> OndatoSDK.Maybe<Self.Element>
  public static func empty() -> OndatoSDK.Maybe<Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Maybe<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> OndatoSDK.Maybe<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> OndatoSDK.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Maybe<Result>) -> OndatoSDK.Maybe<Result>
  public func ifEmpty(default: Self.Element) -> OndatoSDK.Single<Self.Element>
  public func ifEmpty(switchTo other: OndatoSDK.Maybe<Self.Element>) -> OndatoSDK.Maybe<Self.Element>
  public func ifEmpty(switchTo other: OndatoSDK.Single<Self.Element>) -> OndatoSDK.Single<Self.Element>
  public func catchAndReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  @available(*, deprecated, renamed: "catchAndReturn(_:)")
  public func catchErrorJustReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.Disposables {
  public static func create() -> any OndatoSDK.Disposable
}
extension OndatoSDK.ObservableType {
  public func `catch`(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "catch(_:)")
  public func catchError(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
  public func catchAndReturn(_ element: Self.Element) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "catchAndReturn(_:)")
  public func catchErrorJustReturn(_ element: Self.Element) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  @available(*, deprecated, renamed: "catch(onSuccess:onFailure:onDisposed:)")
  public static func catchError<Sequence>(_ sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
  public static func `catch`<Sequence>(sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func retry() -> OndatoSDK.Observable<Self.Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
public protocol ObservableConvertibleType {
  associatedtype Element
  func asObservable() -> OndatoSDK.Observable<Self.Element>
}
public enum PassportAuthenticationStatus {
  case notDone
  case success
  case failed
  public static func == (a: OndatoSDK.PassportAuthenticationStatus, b: OndatoSDK.PassportAuthenticationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class NFCPassportModel {
  public var documentType: Swift.String {
    get
  }
  public var documentSubType: Swift.String {
    get
  }
  public var personalNumber: Swift.String {
    get
  }
  public var documentNumber: Swift.String {
    get
  }
  public var issuingAuthority: Swift.String {
    get
  }
  public var documentExpiryDate: Swift.String {
    get
  }
  public var dateOfBirth: Swift.String {
    get
  }
  public var gender: Swift.String {
    get
  }
  public var nationality: Swift.String {
    get
  }
  public var lastName: Swift.String {
    get
  }
  public var firstName: Swift.String {
    get
  }
  public var passportMRZ: Swift.String {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var residenceAddress: Swift.String? {
    get
  }
  public var phoneNumber: Swift.String? {
    get
  }
  public var documentSigningCertificate: OndatoSDK.X509Wrapper? {
    get
  }
  public var countrySigningCertificate: OndatoSDK.X509Wrapper? {
    get
  }
  public var LDSVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  public var dataGroupsAvailable: [OndatoSDK.DataGroupId] {
    get
  }
  public var dataGroupsRead: [OndatoSDK.DataGroupId : OndatoSDK.DataGroup] {
    get
  }
  public var dataGroupHashes: [OndatoSDK.DataGroupId : OndatoSDK.DataGroupHash] {
    get
  }
  public var cardAccess: OndatoSDK.CardAccess? {
    get
  }
  public var BACStatus: OndatoSDK.PassportAuthenticationStatus {
    get
  }
  public var PACEStatus: OndatoSDK.PassportAuthenticationStatus {
    get
  }
  public var chipAuthenticationStatus: OndatoSDK.PassportAuthenticationStatus {
    get
  }
  public var passportCorrectlySigned: Swift.Bool {
    get
  }
  public var documentSigningCertificateVerified: Swift.Bool {
    get
  }
  public var passportDataNotTampered: Swift.Bool {
    get
  }
  public var activeAuthenticationPassed: Swift.Bool {
    get
  }
  public var activeAuthenticationChallenge: [Swift.UInt8] {
    get
  }
  public var activeAuthenticationSignature: [Swift.UInt8] {
    get
  }
  public var verificationErrors: [any Swift.Error] {
    get
  }
  public var isPACESupported: Swift.Bool {
    get
  }
  public var isChipAuthenticationSupported: Swift.Bool {
    get
  }
  public var passportImage: UIKit.UIImage? {
    get
  }
  public var signatureImage: UIKit.UIImage? {
    get
  }
  public var activeAuthenticationSupported: Swift.Bool {
    get
  }
  public init()
  public init(from dump: [Swift.String : Swift.String])
  public func addDataGroup(_ id: OndatoSDK.DataGroupId, dataGroup: OndatoSDK.DataGroup)
  public func getDataGroup(_ id: OndatoSDK.DataGroupId) -> OndatoSDK.DataGroup?
  public func dumpPassportData(selectedDataGroups: [OndatoSDK.DataGroupId], includeActiveAuthenticationData: Swift.Bool = false) -> [Swift.String : Swift.String]
  public func getHashesForDatagroups(hashAlgorythm: Swift.String) -> [OndatoSDK.DataGroupId : [Swift.UInt8]]
  public func verifyPassport(masterListURL: Foundation.URL?, useCMSVerification: Swift.Bool = false)
  public func verifyActiveAuthentication(challenge: [Swift.UInt8], signature: [Swift.UInt8])
  @objc deinit
}
extension CoreFoundation.CGRect : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreFoundation.CGRect.KVOType)
}
extension CoreFoundation.CGPoint : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreFoundation.CGPoint.KVOType)
}
extension CoreFoundation.CGSize : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreFoundation.CGSize.KVOType)
}
extension UIKit.UICollectionView : OndatoSDK.HasDataSource {
  public typealias DataSource = UIKit.UICollectionViewDataSource
}
open class RxCollectionViewDataSourceProxy : OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSource>, OndatoSDK.DelegateProxyType {
  weak public var collectionView: UIKit.UICollectionView? {
    get
  }
  public init(collectionView: OndatoSDK.RxCollectionViewDataSourceProxy.ParentObject)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UICollectionViewDataSource)?, retainDelegate: Swift.Bool)
  @objc deinit
}
extension OndatoSDK.RxCollectionViewDataSourceProxy : UIKit.UICollectionViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, numberOfItemsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, cellForItemAt indexPath: Foundation.IndexPath) -> UIKit.UICollectionViewCell
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup15 : OndatoSDK.DataGroup {
  public var rsaPublicKey: Swift.OpaquePointer? {
    get
  }
  public var ecdsaPublicKey: Swift.OpaquePointer? {
    get
  }
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UIActivityIndicatorView {
  public var isAnimating: OndatoSDK.Binder<Swift.Bool> {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ReplayRelay<Element> : OndatoSDK.ObservableType {
  final public func accept(_ event: Element)
  public static func create(bufferSize: Swift.Int) -> OndatoSDK.ReplayRelay<Element>
  public static func createUnbound() -> OndatoSDK.ReplayRelay<Element>
  final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, _ source6: OndatoSDK.Infallible<E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, _ source6: OndatoSDK.Infallible<E6>, _ source7: OndatoSDK.Infallible<E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.Infallible<E1>, _ source2: OndatoSDK.Infallible<E2>, _ source3: OndatoSDK.Infallible<E3>, _ source4: OndatoSDK.Infallible<E4>, _ source5: OndatoSDK.Infallible<E5>, _ source6: OndatoSDK.Infallible<E6>, _ source7: OndatoSDK.Infallible<E7>, _ source8: OndatoSDK.Infallible<E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UIGestureRecognizer {
  public var event: OndatoSDK.ControlEvent<Base> {
    get
  }
}
@_inheritsConvenienceInitializers final public class PublishSubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.Cancelable, OndatoSDK.ObserverType {
  public typealias SubjectObserverType = OndatoSDK.PublishSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: OndatoSDK.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObserver() -> OndatoSDK.PublishSubject<Element>
  final public func dispose()
  public typealias Observer = OndatoSDK.PublishSubject<Element>
  @objc deinit
}
public protocol RxPickerViewDataSourceType {
  associatedtype Element
  func pickerView(_ pickerView: UIKit.UIPickerView, observedEvent: OndatoSDK.Event<Self.Element>)
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.SharedSequence {
  @_Concurrency.MainActor public var values: _Concurrency.AsyncStream<Element> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public static func from(optional: Self.Element?) -> OndatoSDK.Observable<Self.Element>
  public static func from(optional: Self.Element?, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UIRefreshControl {
  public var isRefreshing: OndatoSDK.Binder<Swift.Bool> {
    get
  }
}
public class Asset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.ObservableType {
  public static func repeatElement(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(Ondato) public class Ondato : ObjectiveC.NSObject {
  @objc public static let sdk: OndatoSDK.Ondato
  @objc weak public var delegate: (any OndatoSDK.OndatoFlowDelegate)?
  @objc public var configuration: OndatoSDK.OndatoServiceConfiguration
  @objc public func setIdentityVerificationId(_ id: Swift.String)
  @objc public func setSetupId(_ setupId: Swift.String)
  @objc public func setClientId(_ clientId: Swift.String)
  @objc public func setClientSecret(_ clientSecret: Swift.String)
  @objc public func instantiateOndatoViewController() -> OndatoSDK.OndatoViewController
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UISwitch {
  public var isOn: OndatoSDK.ControlProperty<Swift.Bool> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.Bool> {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public struct DataGroupHash {
  public var id: Swift.String
  public var sodHash: Swift.String
  public var computedHash: Swift.String
  public var match: Swift.Bool
}
public protocol ControlEventType : OndatoSDK.ObservableType {
  func asControlEvent() -> OndatoSDK.ControlEvent<Self.Element>
}
public struct ControlEvent<PropertyType> : OndatoSDK.ControlEventType {
  public typealias Element = PropertyType
  public init<Ev>(events: Ev) where PropertyType == Ev.Element, Ev : OndatoSDK.ObservableType
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where PropertyType == Observer.Element, Observer : OndatoSDK.ObserverType
  public func asObservable() -> OndatoSDK.Observable<OndatoSDK.ControlEvent<PropertyType>.Element>
  public func asControlEvent() -> OndatoSDK.ControlEvent<OndatoSDK.ControlEvent<PropertyType>.Element>
}
extension UIKit.UIColor {
  public var lottieColorValue: OndatoSDK.Color {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> OndatoSDK.Observable<Result>
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.Observable<(O1.Element, O2.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationPublicKeyInfo : OndatoSDK.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  @objc deinit
}
@frozen public enum Event<Element> {
  case next(Element)
  case error(any Swift.Error)
  case completed
}
extension OndatoSDK.Event : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.Event {
  public var isStopEvent: Swift.Bool {
    get
  }
  public var element: Element? {
    get
  }
  public var error: (any Swift.Error)? {
    get
  }
  public var isCompleted: Swift.Bool {
    get
  }
}
extension OndatoSDK.Event {
  public func map<Result>(_ transform: (Element) throws -> Result) -> OndatoSDK.Event<Result>
}
public protocol EventConvertible {
  associatedtype Element
  var event: OndatoSDK.Event<Self.Element> { get }
}
extension OndatoSDK.Event : OndatoSDK.EventConvertible {
  public var event: OndatoSDK.Event<Element> {
    get
  }
}
public struct KeyValueObservingOptions : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let initial: OndatoSDK.KeyValueObservingOptions
  public static let new: OndatoSDK.KeyValueObservingOptions
  public typealias ArrayLiteralElement = OndatoSDK.KeyValueObservingOptions
  public typealias Element = OndatoSDK.KeyValueObservingOptions
  public typealias RawValue = Swift.UInt
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> OndatoSDK.Observable<Element?> where Element : OndatoSDK.KVORepresentable
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element?> where Element : OndatoSDK.KVORepresentable
}
extension OndatoSDK.Reactive where Base : UIKit.UISearchController {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UISearchController, any UIKit.UISearchControllerDelegate> {
    get
  }
  public var didDismiss: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var didPresent: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var present: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var willDismiss: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public var willPresent: OndatoSDK.Observable<Swift.Void> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIApplication {
  public var isNetworkActivityIndicatorVisible: OndatoSDK.Binder<Swift.Bool> {
    get
  }
  public static var didEnterBackground: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var willEnterForeground: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var didFinishLaunching: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var didBecomeActive: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var willResignActive: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var didReceiveMemoryWarning: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var willTerminate: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var significantTimeChange: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var backgroundRefreshStatusDidChange: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var protectedDataWillBecomeUnavailable: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var protectedDataDidBecomeAvailable: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public static var userDidTakeScreenshot: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
}
extension OndatoSDK.BehaviorRelay {
  final public func asDriver() -> OndatoSDK.Driver<Element>
}
extension OndatoSDK.ObservableType {
  public func subscribe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "subscribe(on:)")
  public func subscribeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
public protocol AnimationImageProvider {
  func imageForAsset(asset: OndatoSDK.ImageAsset) -> CoreGraphics.CGImage?
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedSwitch : OndatoSDK.AnimatedControl {
  @_Concurrency.MainActor(unsafe) override public init(animation: OndatoSDK.Animation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: OndatoSDK.AnimatedSwitch.CancelBehavior, b: OndatoSDK.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var cancelBehavior: OndatoSDK.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor(unsafe) public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func setProgressForState(fromProgress: OndatoSDK.AnimationProgressTime, toProgress: OndatoSDK.AnimationProgressTime, forOnState: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) override public func animationDidSet()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ConcurrentMainScheduler : OndatoSDK.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  final public var now: Foundation.Date {
    get
  }
  public static let instance: OndatoSDK.ConcurrentMainScheduler
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup11 : OndatoSDK.DataGroup {
  public var fullName: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var dateOfBirth: Swift.String? {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var address: Swift.String? {
    get
  }
  public var telephone: Swift.String? {
    get
  }
  public var profession: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var personalSummary: Swift.String? {
    get
  }
  public var proofOfCitizenship: Swift.String? {
    get
  }
  public var tdNumbers: Swift.String? {
    get
  }
  public var custodyInfo: Swift.String? {
    get
  }
  @objc deinit
}
public protocol AnimationCacheProvider {
  func animation(forKey: Swift.String) -> OndatoSDK.Animation?
  func setAnimation(_ animation: OndatoSDK.Animation, forKey: Swift.String)
  func clearCache()
}
public enum SubjectLifetimeScope {
  case whileConnected
  case forever
  public static func == (a: OndatoSDK.SubjectLifetimeScope, b: OndatoSDK.SubjectLifetimeScope) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func share(replay: Swift.Int = 0, scope: OndatoSDK.SubjectLifetimeScope = .whileConnected) -> OndatoSDK.Observable<Self.Element>
}
public enum RxError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case disposed(object: Swift.AnyObject)
  case overflow
  case argumentOutOfRange
  case noElements
  case moreThanOneElement
  case timeout
}
extension OndatoSDK.RxError {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.ObservableType {
  public static func empty() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func concat<Source>(_ second: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableConvertibleType, Self.Element == Source.Element
}
extension OndatoSDK.ObservableType {
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Observable<Self.Element>
  public static func concat(_ sources: OndatoSDK.Observable<Self.Element>...) -> OndatoSDK.Observable<Self.Element>
}
public struct Disposables {
}
public typealias ParsedResult = OndatoSDK.MRZResult
public struct MRZParser {
  public init(isOCRCorrectionEnabled: Swift.Bool)
  public func parse(mrzLines: [Swift.String]) -> OndatoSDK.MRZResult?
  public func parse(mrzString: Swift.String) -> OndatoSDK.MRZResult?
}
final public class PointValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
extension OndatoSDK.ObservableType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) throws -> Key) -> OndatoSDK.Observable<Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) throws -> K, comparer: @escaping (K, K) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  public func distinctUntilChanged<Property>(at keyPath: Swift.KeyPath<Self.Element, Property>) -> OndatoSDK.Observable<Self.Element> where Property : Swift.Equatable
}
extension OndatoSDK.ObservableType {
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, observableFactory: @escaping (Resource) throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element> where Resource : OndatoSDK.Disposable
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  public static func == (a: OndatoSDK.LottieBackgroundBehavior, b: OndatoSDK.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
}
extension OndatoSDK.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: OndatoSDK.LottieLoopMode, rhs: OndatoSDK.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) final public class AnimationView : OndatoSDK.LottieView {
  @_Concurrency.MainActor(unsafe) public init(animation: OndatoSDK.Animation?, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, textProvider: any OndatoSDK.AnimationTextProvider = DefaultTextProvider(), fontProvider: any OndatoSDK.AnimationFontProvider = DefaultFontProvider())
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame _: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) final public var backgroundBehavior: OndatoSDK.LottieBackgroundBehavior
  @_Concurrency.MainActor(unsafe) final public var animation: OndatoSDK.Animation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var imageProvider: any OndatoSDK.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var textProvider: any OndatoSDK.AnimationTextProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var fontProvider: any OndatoSDK.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var loopMode: OndatoSDK.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentProgress: OndatoSDK.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentFrame: OndatoSDK.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var realtimeAnimationFrame: OndatoSDK.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var realtimeAnimationProgress: OndatoSDK.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) final public func play(completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromProgress: OndatoSDK.AnimationProgressTime? = nil, toProgress: OndatoSDK.AnimationProgressTime, loopMode: OndatoSDK.LottieLoopMode? = nil, completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromFrame: OndatoSDK.AnimationFrameTime? = nil, toFrame: OndatoSDK.AnimationFrameTime, loopMode: OndatoSDK.LottieLoopMode? = nil, completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, loopMode: OndatoSDK.LottieLoopMode? = nil, completion: OndatoSDK.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func stop()
  @_Concurrency.MainActor(unsafe) final public func pause()
  @_Concurrency.MainActor(unsafe) final public func reloadImages()
  @_Concurrency.MainActor(unsafe) final public func forceDisplayUpdate()
  @_Concurrency.MainActor(unsafe) final public func setValueProvider(_ valueProvider: any OndatoSDK.AnyValueProvider, keypath: OndatoSDK.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func getValue(for keypath: OndatoSDK.AnimationKeypath, atFrame: OndatoSDK.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor(unsafe) final public func logHierarchyKeypaths()
  @_Concurrency.MainActor(unsafe) final public func addSubview(_ subview: OndatoSDK.AnimationSubview, forLayerAt keypath: OndatoSDK.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: OndatoSDK.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor(unsafe) final public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: OndatoSDK.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor(unsafe) final public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: OndatoSDK.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func progressTime(forMarker named: Swift.String) -> OndatoSDK.AnimationProgressTime?
  @_Concurrency.MainActor(unsafe) final public func frameTime(forMarker named: Swift.String) -> OndatoSDK.AnimationFrameTime?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConnectableObservable<Element> : OndatoSDK.Observable<Element>, OndatoSDK.ConnectableObservableType {
  public func connect() -> any OndatoSDK.Disposable
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func multicast<Subject, Result>(_ subjectSelector: @escaping () throws -> Subject, selector: @escaping (OndatoSDK.Observable<Subject.Element>) throws -> OndatoSDK.Observable<Result>) -> OndatoSDK.Observable<Result> where Subject : OndatoSDK.SubjectType, Self.Element == Subject.Observer.Element
}
extension OndatoSDK.ObservableType {
  public func publish() -> OndatoSDK.ConnectableObservable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func replay(_ bufferSize: Swift.Int) -> OndatoSDK.ConnectableObservable<Self.Element>
  public func replayAll() -> OndatoSDK.ConnectableObservable<Self.Element>
}
extension OndatoSDK.ConnectableObservableType {
  public func refCount() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func multicast<Subject>(_ subject: Subject) -> OndatoSDK.ConnectableObservable<Subject.Element> where Subject : OndatoSDK.SubjectType, Self.Element == Subject.Observer.Element
  public func multicast<Subject>(makeSubject: @escaping () -> Subject) -> OndatoSDK.ConnectableObservable<Subject.Element> where Subject : OndatoSDK.SubjectType, Self.Element == Subject.Observer.Element
}
final public class GradientValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.GradientValueProvider.ColorsValueBlock, locations: OndatoSDK.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [OndatoSDK.Color], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [OndatoSDK.Color]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [OndatoSDK.Color] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func observe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "observe(on:)")
  public func observeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
public enum SharingScheduler {
  public static var make: () -> any OndatoSDK.SchedulerType {
    get
  }
  public static func mock(scheduler: any OndatoSDK.SchedulerType, action: () throws -> Swift.Void) rethrows
  public static func mock(makeScheduler: @escaping () -> any OndatoSDK.SchedulerType, action: () throws -> Swift.Void) rethrows
}
extension OndatoSDK.ObservableType {
  public func sample<Source>(_ sampler: Source, defaultValue: Self.Element? = nil) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public func asSingle() -> OndatoSDK.Single<Self.Element>
  public func first() -> OndatoSDK.Single<Self.Element?>
  public func asMaybe() -> OndatoSDK.Maybe<Self.Element>
}
extension OndatoSDK.ObservableType where Self.Element == Swift.Never {
  public func asCompletable() -> OndatoSDK.Completable
}
@_inheritsConvenienceInitializers @objc(OndatoAppearance) public class OndatoAppearance : ObjectiveC.NSObject {
  @objc public var consentWindow: OndatoSDK.OndatoConsentAppearance
  @objc public var progressColor: UIKit.UIColor
  @objc public var errorColor: UIKit.UIColor
  @objc public var errorTextColor: UIKit.UIColor
  @objc public var buttonColor: UIKit.UIColor
  @objc public var buttonTextColor: UIKit.UIColor
  @objc public var textColor: UIKit.UIColor
  @objc public var backgroundColor: UIKit.UIColor
  @objc public var imageTintColor: UIKit.UIColor
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(OndatoGDRPAppearance) public class OndatoConsentAppearance : ObjectiveC.NSObject {
  @objc public var header: OndatoSDK.OndatoLabelAppearance
  @objc public var body: OndatoSDK.OndatoTextViewAppearance
  @objc public var acceptButton: OndatoSDK.OndatoButtonAppearance
  @objc public var declineButton: OndatoSDK.OndatoButtonAppearance
  @objc override dynamic public init()
  @objc deinit
}
@objc(OndatoButtonAppearance) public class OndatoButtonAppearance : ObjectiveC.NSObject {
  @objc public var font: UIKit.UIFont
  @objc public var backgroundColor: UIKit.UIColor
  @objc public var tintColor: UIKit.UIColor
  @objc public var borderWidth: CoreFoundation.CGFloat
  @objc public var borderColor: UIKit.UIColor
  @objc public var cornerRadius: CoreFoundation.CGFloat
  public init(font: UIKit.UIFont = .systemFont(ofSize: 15), backgroundColor: UIKit.UIColor = .clear, tintColor: UIKit.UIColor = .systemBlue, borderWidth: CoreFoundation.CGFloat = 0, borderColor: UIKit.UIColor = .clear, cornerRadius: CoreFoundation.CGFloat = 0)
  @objc deinit
}
@objc(OndatoLabelAppearance) public class OndatoLabelAppearance : ObjectiveC.NSObject {
  @objc public var font: UIKit.UIFont
  @objc public var color: UIKit.UIColor
  public init(font: UIKit.UIFont = .systemFont(ofSize: 15, weight: .semibold), color: UIKit.UIColor = .black)
  @objc deinit
}
@objc(OndatoTextViewAppearance) public class OndatoTextViewAppearance : ObjectiveC.NSObject {
  @objc public var font: UIKit.UIFont
  @objc public var textColor: UIKit.UIColor
  public init(font: UIKit.UIFont = .systemFont(ofSize: 15), textColor: UIKit.UIColor = .black)
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBar {
  public var willBeginCustomizing: OndatoSDK.ControlEvent<[UIKit.UITabBarItem]> {
    get
  }
  public var didBeginCustomizing: OndatoSDK.ControlEvent<[UIKit.UITabBarItem]> {
    get
  }
  public var willEndCustomizing: OndatoSDK.ControlEvent<([UIKit.UITabBarItem], Swift.Bool)> {
    get
  }
  public var didEndCustomizing: OndatoSDK.ControlEvent<([UIKit.UITabBarItem], Swift.Bool)> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBar {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UITabBar, any UIKit.UITabBarDelegate> {
    get
  }
  public var didSelectItem: OndatoSDK.ControlEvent<UIKit.UITabBarItem> {
    get
  }
}
extension OndatoSDK.Vector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.Vector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.Vector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
public enum InfallibleEvent<Element> {
  case next(Element)
  case completed
}
extension OndatoSDK.Infallible {
  public typealias InfallibleObserver = (OndatoSDK.InfallibleEvent<Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping OndatoSDK.Infallible<Element>.InfallibleObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.Infallible<Element>
}
public enum CoordinateSpace : Swift.Int, Swift.Codable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class Animation : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let startFrame: OndatoSDK.AnimationFrameTime
  final public let endFrame: OndatoSDK.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(OndatoLogManager) public class OndatoLogManager : ObjectiveC.NSObject {
  @objc public static let manager: OndatoSDK.OndatoLogManager
  @objc public func showLogButton()
  @objc public func hideLogButton()
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Observable<Self.Element>
}
final public class SizeValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
final public class PublishRelay<Element> : OndatoSDK.ObservableType {
  final public func accept(_ event: Element)
  public init()
  final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
public struct ImageMRZScanner {
  public init()
  public func scan(scanningImage: OndatoSDK.ScanningImage, orientation: ImageIO.CGImagePropertyOrientation, regionOfInterest: CoreFoundation.CGRect? = nil, minimumTextHeight: Swift.Float? = nil, recognitionLevel: OndatoSDK.RecognitionLevel = .accurate, foundBoundingRectsHandler: (([CoreFoundation.CGRect]) -> Swift.Void)? = nil, completionHandler: @escaping (Swift.Result<OndatoSDK.DocumentScanningResult<OndatoSDK.ParsedResult>, any Swift.Error>) -> Swift.Void)
}
public enum RxCocoaInterceptionMechanism {
  case unknown
  case kvo
  public static func == (a: OndatoSDK.RxCocoaInterceptionMechanism, b: OndatoSDK.RxCocoaInterceptionMechanism) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum RxCocoaObjCRuntimeError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown(target: Swift.AnyObject)
  case objectMessagesAlreadyBeingIntercepted(target: Swift.AnyObject, interceptionMechanism: OndatoSDK.RxCocoaInterceptionMechanism)
  case selectorNotImplemented(target: Swift.AnyObject)
  case cantInterceptCoreFoundationTollFreeBridgedObjects(target: Swift.AnyObject)
  case threadingCollisionWithOtherInterceptionMechanism(target: Swift.AnyObject)
  case savingOriginalForwardingMethodFailed(target: Swift.AnyObject)
  case replacingMethodWithForwardingImplementation(target: Swift.AnyObject)
  case observingPerformanceSensitiveMessages(target: Swift.AnyObject)
  case observingMessagesWithUnsupportedReturnType(target: Swift.AnyObject)
}
extension OndatoSDK.RxCocoaObjCRuntimeError {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol KVORepresentable {
  associatedtype KVOType
  init?(KVOValue: Self.KVOType)
}
extension UIKit.UISearchController : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UISearchControllerDelegate
}
open class RxSearchControllerDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UISearchController, any UIKit.UISearchControllerDelegate>, OndatoSDK.DelegateProxyType {
  weak public var searchController: UIKit.UISearchController? {
    get
  }
  public init(searchController: UIKit.UISearchController)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxSearchControllerDelegateProxy : UIKit.UISearchControllerDelegate {
}
public protocol ObservableType : OndatoSDK.ObservableConvertibleType {
  func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
}
extension OndatoSDK.ObservableType {
  public func asObservable() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func skip<Source>(until other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "skip(until:)")
  public func skipUntil<Source>(_ other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
}
public class OperationQueueScheduler : OndatoSDK.ImmediateSchedulerType {
  final public let operationQueue: Foundation.OperationQueue
  final public let queuePriority: Foundation.Operation.QueuePriority
  public init(operationQueue: Foundation.OperationQueue, queuePriority: Foundation.Operation.QueuePriority = .normal)
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  @objc deinit
}
public protocol DelegateProxyType : AnyObject {
  associatedtype ParentObject : AnyObject
  associatedtype Delegate
  static func registerKnownImplementations()
  static var identifier: Swift.UnsafeRawPointer { get }
  static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
  func forwardToDelegate() -> Self.Delegate?
  func setForwardToDelegate(_ forwardToDelegate: Self.Delegate?, retainDelegate: Swift.Bool)
}
extension OndatoSDK.DelegateProxyType {
  public static var identifier: Swift.UnsafeRawPointer {
    get
  }
}
extension OndatoSDK.DelegateProxyType {
  public static func register<Parent>(make: @escaping (Parent) -> Self)
  public static func createProxy(for object: Swift.AnyObject) -> Self
  public static func proxy(for object: Self.ParentObject) -> Self
  public static func installForwardDelegate(_ forwardDelegate: Self.Delegate, retainDelegate: Swift.Bool, onProxyForObject object: Self.ParentObject) -> any OndatoSDK.Disposable
}
public protocol HasDelegate : AnyObject {
  associatedtype Delegate
  var delegate: Self.Delegate? { get set }
}
extension OndatoSDK.DelegateProxyType where Self.Delegate == Self.ParentObject.Delegate, Self.ParentObject : OndatoSDK.HasDelegate {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
public protocol HasDataSource : AnyObject {
  associatedtype DataSource
  var dataSource: Self.DataSource? { get set }
}
extension OndatoSDK.DelegateProxyType where Self.Delegate == Self.ParentObject.DataSource, Self.ParentObject : OndatoSDK.HasDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
@available(iOS 10.0, tvOS 10.0, *)
public protocol HasPrefetchDataSource : AnyObject {
  associatedtype PrefetchDataSource
  var prefetchDataSource: Self.PrefetchDataSource? { get set }
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.DelegateProxyType where Self.Delegate == Self.ParentObject.PrefetchDataSource, Self.ParentObject : OndatoSDK.HasPrefetchDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
final public class FloatValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
extension OndatoSDK.ObservableType where Self.Element == Foundation.Data {
  public func decode<Item, Decoder>(type: Item.Type, decoder: Decoder) -> OndatoSDK.Observable<Item> where Item : Swift.Decodable, Decoder : OndatoSDK.DataDecoder
}
public protocol DataDecoder {
  func decode<Item>(_ type: Item.Type, from data: Foundation.Data) throws -> Item where Item : Swift.Decodable
}
extension Foundation.JSONDecoder : OndatoSDK.DataDecoder {
}
extension Foundation.PropertyListDecoder : OndatoSDK.DataDecoder {
}
extension UIKit.UITableView : OndatoSDK.HasDataSource {
  public typealias DataSource = UIKit.UITableViewDataSource
}
open class RxTableViewDataSourceProxy : OndatoSDK.DelegateProxy<UIKit.UITableView, any UIKit.UITableViewDataSource>, OndatoSDK.DelegateProxyType {
  weak public var tableView: UIKit.UITableView? {
    get
  }
  public init(tableView: UIKit.UITableView)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UITableViewDataSource)?, retainDelegate: Swift.Bool)
  @objc deinit
}
extension OndatoSDK.RxTableViewDataSourceProxy : UIKit.UITableViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
}
@_Concurrency.MainActor(unsafe) open class RxCollectionViewDelegateProxy : OndatoSDK.RxScrollViewDelegateProxy {
  @_Concurrency.MainActor(unsafe) weak public var collectionView: UIKit.UICollectionView? {
    get
  }
  @_Concurrency.MainActor(unsafe) public init(collectionView: UIKit.UICollectionView)
  @objc deinit
}
extension OndatoSDK.RxCollectionViewDelegateProxy : UIKit.UICollectionViewDelegateFlowLayout {
}
extension OndatoSDK.ObservableType {
  public func subscribe(_ on: @escaping (OndatoSDK.Event<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onError: ((Object, any Swift.Error) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onNext: ((Self.Element) -> Swift.Void)? = nil, onError: ((any Swift.Error) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.Hooks {
  public typealias DefaultErrorHandler = (_ subscriptionCallStack: [Swift.String], _ error: any Swift.Error) -> Swift.Void
  public typealias CustomCaptureSubscriptionCallstack = () -> [Swift.String]
  public static var defaultErrorHandler: OndatoSDK.Hooks.DefaultErrorHandler {
    get
    set
  }
  public static var customCaptureSubscriptionCallstack: OndatoSDK.Hooks.CustomCaptureSubscriptionCallstack {
    get
    set
  }
}
extension UIKit.UIPickerView : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UIPickerViewDelegate
}
open class RxPickerViewDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDelegate>, OndatoSDK.DelegateProxyType {
  weak public var pickerView: UIKit.UIPickerView? {
    get
  }
  public init(pickerView: OndatoSDK.RxPickerViewDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxPickerViewDelegateProxy : UIKit.UIPickerViewDelegate {
}
extension OndatoSDK.ObservableType {
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> OndatoSDK.Observable<Result>
}
extension OndatoSDK.ObservableType {
  public func takeLast(_ count: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
public protocol ConnectableObservableType : OndatoSDK.ObservableType {
  func connect() -> any OndatoSDK.Disposable
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.DriverSharingStrategy {
  public func drive<Observer>(_ observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func drive<Observer>(_ observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func drive(_ relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func drive(_ relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func drive(_ relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func drive(_ relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func drive<Result>(_ transformation: (OndatoSDK.Observable<Self.Element>) -> Result) -> Result
  public func drive<R1, R2>(_ with: (OndatoSDK.Observable<Self.Element>) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func drive<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func drive(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func drive() -> any OndatoSDK.Disposable
}
extension OndatoSDK.ObservableConvertibleType {
  public func asDriver(onErrorJustReturn: Self.Element) -> OndatoSDK.Driver<Self.Element>
  public func asDriver(onErrorDriveWith: OndatoSDK.Driver<Self.Element>) -> OndatoSDK.Driver<Self.Element>
  public func asDriver(onErrorRecover: @escaping (_ error: any Swift.Error) -> OndatoSDK.Driver<Self.Element>) -> OndatoSDK.Driver<Self.Element>
}
open class DelegateProxy<P, D> : OndatoSDK._RXDelegateProxy where P : AnyObject {
  public typealias ParentObject = P
  public typealias Delegate = D
  public init<Proxy>(parentObject: OndatoSDK.DelegateProxy<P, D>.ParentObject, delegateProxy: Proxy.Type) where P == Proxy.ParentObject, D == Proxy.Delegate, Proxy : OndatoSDK.DelegateProxy<P, D>, Proxy : OndatoSDK.DelegateProxyType
  open func sentMessage(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  open func methodInvoked(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  @objc override dynamic open func _sentMessage(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  @objc override dynamic open func _methodInvoked(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  open func forwardToDelegate() -> OndatoSDK.DelegateProxy<P, D>.Delegate?
  open func setForwardToDelegate(_ delegate: OndatoSDK.DelegateProxy<P, D>.Delegate?, retainDelegate: Swift.Bool)
  @objc(respondsToSelector:) override dynamic open func responds(to aSelector: ObjectiveC.Selector!) -> Swift.Bool
  @objc deinit
}
@_inheritsConvenienceInitializers final public class SingleAssignmentDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public func setDisposable(_ disposable: any OndatoSDK.Disposable)
  final public func dispose()
  @objc deinit
}
public struct Binder<Value> : OndatoSDK.ObserverType {
  public typealias Element = Value
  public init<Target>(_ target: Target, scheduler: any OndatoSDK.ImmediateSchedulerType = MainScheduler(), binding: @escaping (Target, Value) -> Swift.Void) where Target : AnyObject
  public func on(_ event: OndatoSDK.Event<Value>)
  public func asObserver() -> OndatoSDK.AnyObserver<Value>
}
extension OndatoSDK.Disposables {
  public static func create(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable) -> any OndatoSDK.Cancelable
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class CardAccess {
  public var securityInfos: [OndatoSDK.SecurityInfo] {
    get
  }
  @objc deinit
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  func hasUpdate(frame: OndatoSDK.AnimationFrameTime) -> Swift.Bool
  func value(frame: OndatoSDK.AnimationFrameTime) -> Any
}
public enum RxCocoaURLError : Swift.Error {
  case unknown
  case nonHTTPResponse(response: Foundation.URLResponse)
  case httpRequestFailed(response: Foundation.HTTPURLResponse, data: Foundation.Data?)
  case deserializationError(error: any Swift.Error)
}
extension OndatoSDK.RxCocoaURLError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension OndatoSDK.Reactive where Base : Foundation.URLSession {
  public func response(request: Foundation.URLRequest) -> OndatoSDK.Observable<(response: Foundation.HTTPURLResponse, data: Foundation.Data)>
  public func data(request: Foundation.URLRequest) -> OndatoSDK.Observable<Foundation.Data>
  public func json(request: Foundation.URLRequest, options: Foundation.JSONSerialization.ReadingOptions = []) -> OndatoSDK.Observable<Any>
  public func json(url: Foundation.URL) -> OndatoSDK.Observable<Any>
}
extension OndatoSDK.Reactive where Base == Foundation.URLSession {
  public static var shouldLogRequest: (Foundation.URLRequest) -> Swift.Bool
}
@available(iOS 8.0, macOS 10.10, macOSApplicationExtension 10.10, *)
open class RxWKNavigationDelegateProxy : OndatoSDK.DelegateProxy<WebKit.WKWebView, any WebKit.WKNavigationDelegate>, OndatoSDK.DelegateProxyType {
  weak public var webView: WebKit.WKWebView? {
    get
  }
  public init(webView: OndatoSDK.RxWKNavigationDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  public static func currentDelegate(for object: WebKit.WKWebView) -> (any WebKit.WKNavigationDelegate)?
  public static func setCurrentDelegate(_ delegate: (any WebKit.WKNavigationDelegate)?, to object: WebKit.WKWebView)
  @objc deinit
}
@available(iOS 8.0, macOS 10.10, macOSApplicationExtension 10.10, *)
extension OndatoSDK.RxWKNavigationDelegateProxy : WebKit.WKNavigationDelegate {
}
@_hasMissingDesignatedInitializers final public class RefCountDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(disposable: any OndatoSDK.Disposable)
  final public func retain() -> any OndatoSDK.Disposable
  final public func dispose()
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func reduce<A, Result>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A, mapResult: @escaping (A) throws -> Result) -> OndatoSDK.Observable<Result>
  public func reduce<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> OndatoSDK.Observable<A>
}
extension OndatoSDK.InfallibleType {
  public static func just(_ element: Self.Element) -> OndatoSDK.Infallible<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Infallible<Self.Element>
  public static func never() -> OndatoSDK.Infallible<Self.Element>
  public static func empty() -> OndatoSDK.Infallible<Self.Element>
  public static func deferred(_ observableFactory: @escaping () throws -> OndatoSDK.Infallible<Self.Element>) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.Infallible {
  public static func of(_ elements: Element..., scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Infallible<Element>
}
extension OndatoSDK.Infallible {
  public static func from(_ array: [Element], scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Infallible<Element>
  public static func from<Sequence>(_ sequence: Sequence, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Infallible<Element> where Element == Sequence.Element, Sequence : Swift.Sequence
}
extension OndatoSDK.InfallibleType {
  public func filter(_ predicate: @escaping (Self.Element) -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func map<Result>(_ transform: @escaping (Self.Element) -> Result) -> OndatoSDK.Infallible<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) -> Result?) -> OndatoSDK.Infallible<Result>
}
extension OndatoSDK.InfallibleType where Self.Element : Swift.Comparable {
  public func distinctUntilChanged() -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) throws -> Key) -> OndatoSDK.Infallible<Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) throws -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) throws -> K, comparer: @escaping (K, K) throws -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
  public func distinctUntilChanged<Property>(at keyPath: Swift.KeyPath<Self.Element, Property>) -> OndatoSDK.Infallible<Self.Element> where Property : Swift.Equatable
}
extension OndatoSDK.InfallibleType {
  public func debounce(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Infallible<Self.Element>
  public func throttle(_ dueTime: OndatoSDK.RxTimeInterval, latest: Swift.Bool = true, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func flatMap<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
  public func flatMapFirst<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.InfallibleType {
  public func concat<Source>(_ second: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.ObservableConvertibleType, Self.Element == Source.Element
  public static func concat<Sequence>(_ sequence: Sequence) -> OndatoSDK.Infallible<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Infallible<Self.Element>
  public static func concat<Collection>(_ collection: Collection) -> OndatoSDK.Infallible<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Infallible<Self.Element>
  public static func concat(_ sources: OndatoSDK.Infallible<Self.Element>...) -> OndatoSDK.Infallible<Self.Element>
  public func concatMap<Source>(_ selector: @escaping (Self.Element) -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.InfallibleType {
  public static func merge<Collection>(_ sources: Collection) -> OndatoSDK.Infallible<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Infallible<Self.Element>
  public static func merge(_ sources: [OndatoSDK.Infallible<Self.Element>]) -> OndatoSDK.Infallible<Self.Element>
  public static func merge(_ sources: OndatoSDK.Infallible<Self.Element>...) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.Infallible {
  public func `do`(onNext: ((Element) throws -> Swift.Void)? = nil, afterNext: ((Element) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Infallible<Element>
}
extension OndatoSDK.InfallibleType {
  public func scan<Seed>(into seed: Seed, accumulator: @escaping (inout Seed, Self.Element) -> Swift.Void) -> OndatoSDK.Infallible<Seed>
  public func scan<Seed>(_ seed: Seed, accumulator: @escaping (Seed, Self.Element) -> Seed) -> OndatoSDK.Infallible<Seed>
}
extension OndatoSDK.InfallibleType {
  public func startWith(_ element: Self.Element) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func take<Source>(until other: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.InfallibleType
  public func take<Source>(until other: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.ObservableType
  public func take(until predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Infallible<Self.Element>
  public func take(while predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Infallible<Self.Element>
  public func take(_ count: Swift.Int) -> OndatoSDK.Infallible<Self.Element>
  public func take(for duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Infallible<Self.Element>
  public func skip(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Infallible<Self.Element>
  public func skip<Source>(until other: Source) -> OndatoSDK.Infallible<Self.Element> where Source : OndatoSDK.ObservableType
}
extension OndatoSDK.InfallibleType {
  public func share(replay: Swift.Int = 0, scope: OndatoSDK.SubjectLifetimeScope = .whileConnected) -> OndatoSDK.Infallible<Self.Element>
}
extension OndatoSDK.InfallibleType {
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.Infallible<Out> where Object : AnyObject
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.Infallible<(Object, Self.Element)> where Object : AnyObject
}
extension OndatoSDK.InfallibleType {
  public func withLatestFrom<Source, ResultType>(_ second: Source, resultSelector: @escaping (Self.Element, Source.Element) throws -> ResultType) -> OndatoSDK.Infallible<ResultType> where Source : OndatoSDK.InfallibleType
  public func withLatestFrom<Source>(_ second: Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.InfallibleType
}
public typealias Driver<Element> = OndatoSDK.SharedSequence<OndatoSDK.DriverSharingStrategy, Element>
public struct DriverSharingStrategy : OndatoSDK.SharingStrategyProtocol {
  public static var scheduler: any OndatoSDK.SchedulerType {
    get
  }
  public static func share<Element>(_ source: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.DriverSharingStrategy {
  public func asDriver() -> OndatoSDK.Driver<Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, resultSelector: @escaping (E1, E2) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, resultSelector: @escaping (E1, E2, E3) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.SingleTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Any, Self.Trait == OndatoSDK.MaybeTrait {
  public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: OndatoSDK.PrimitiveSequence<Self.Trait, E1>, _ source2: OndatoSDK.PrimitiveSequence<Self.Trait, E2>, _ source3: OndatoSDK.PrimitiveSequence<Self.Trait, E3>, _ source4: OndatoSDK.PrimitiveSequence<Self.Trait, E4>, _ source5: OndatoSDK.PrimitiveSequence<Self.Trait, E5>, _ source6: OndatoSDK.PrimitiveSequence<Self.Trait, E6>, _ source7: OndatoSDK.PrimitiveSequence<Self.Trait, E7>, _ source8: OndatoSDK.PrimitiveSequence<Self.Trait, E8>) -> OndatoSDK.PrimitiveSequence<Self.Trait, (E1, E2, E3, E4, E5, E6, E7, E8)>
}
@available(iOS 10.0, tvOS 10.0, *)
extension UIKit.UICollectionView : OndatoSDK.HasPrefetchDataSource {
  public typealias PrefetchDataSource = UIKit.UICollectionViewDataSourcePrefetching
}
@available(iOS 10.0, tvOS 10.0, *)
open class RxCollectionViewDataSourcePrefetchingProxy : OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSourcePrefetching>, OndatoSDK.DelegateProxyType {
  weak public var collectionView: UIKit.UICollectionView? {
    get
  }
  public init(collectionView: OndatoSDK.RxCollectionViewDataSourcePrefetchingProxy.ParentObject)
  public static func registerKnownImplementations()
  override open func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UICollectionViewDataSourcePrefetching)?, retainDelegate: Swift.Bool)
  @objc deinit
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.RxCollectionViewDataSourcePrefetchingProxy : UIKit.UICollectionViewDataSourcePrefetching {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func collectionView(_ collectionView: UIKit.UICollectionView, prefetchItemsAt indexPaths: [Foundation.IndexPath])
}
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : OndatoSDK.AnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func window(timeSpan: OndatoSDK.RxTimeInterval, count: Swift.Int, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<OndatoSDK.Observable<Self.Element>>
}
public typealias ItemMovedEvent = (sourceIndex: Foundation.IndexPath, destinationIndex: Foundation.IndexPath)
public typealias WillDisplayCellEvent = (cell: UIKit.UITableViewCell, indexPath: Foundation.IndexPath)
public typealias DidEndDisplayingCellEvent = (cell: UIKit.UITableViewCell, indexPath: Foundation.IndexPath)
extension OndatoSDK.ControlProperty {
  public func asDriver() -> OndatoSDK.Driver<OndatoSDK.ControlProperty<PropertyType>.Element>
}
extension OndatoSDK.ObservableType {
  public func buffer(timeSpan: OndatoSDK.RxTimeInterval, count: Swift.Int, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<[Self.Element]>
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.EventConvertible {
  public func dematerialize() -> OndatoSDK.Observable<Self.Element.Element>
}
public struct HistoricalSchedulerTimeConverter : OndatoSDK.VirtualTimeConverterType {
  public typealias VirtualTimeUnit = OndatoSDK.RxTime
  public typealias VirtualTimeIntervalUnit = Foundation.TimeInterval
  public func convertFromVirtualTime(_ virtualTime: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> OndatoSDK.RxTime
  public func convertToVirtualTime(_ time: OndatoSDK.RxTime) -> OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func convertFromVirtualTimeInterval(_ virtualTimeInterval: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  public func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit
  public func offsetVirtualTime(_ time: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit, offset: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeIntervalUnit) -> OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit
  public func compareVirtualTime(_ lhs: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit, _ rhs: OndatoSDK.HistoricalSchedulerTimeConverter.VirtualTimeUnit) -> OndatoSDK.VirtualTimeComparison
}
@objc(OndatoSupportedLanguage) public enum OndatoSupportedLanguage : Swift.Int, Swift.RawRepresentable {
  case BG
  case DE
  case EN
  case ES
  case ET
  case FR
  case EL
  case IT
  case LT
  case LV
  case NL
  case RO
  case RU
  case SQ
  public typealias RawValue = Swift.String
  public var rawValue: OndatoSDK.OndatoSupportedLanguage.RawValue {
    get
  }
  public var displayName: Swift.String {
    get
  }
  public init?(rawValue: OndatoSDK.OndatoSupportedLanguage.RawValue)
}
extension OndatoSDK.OndatoSupportedLanguage : Swift.CaseIterable {
  public typealias AllCases = [OndatoSDK.OndatoSupportedLanguage]
  public static var allCases: [OndatoSDK.OndatoSupportedLanguage] {
    get
  }
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> OndatoSDK.Observable<Element?>
  public func observe<Element>(_ keyPath: Swift.KeyPath<Base, Element>, options: Foundation.NSKeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: OndatoSDK.KeyValueObservingOptions = [.new, .initial]) -> OndatoSDK.Observable<Element?>
}
extension OndatoSDK.Reactive where Base : AnyObject {
  public var deallocated: OndatoSDK.Observable<Swift.Void> {
    get
  }
  public func sentMessage(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  public func methodInvoked(_ selector: ObjectiveC.Selector) -> OndatoSDK.Observable<[Any]>
  public var deallocating: OndatoSDK.Observable<()> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func groupBy<Key>(keySelector: @escaping (Self.Element) throws -> Key) -> OndatoSDK.Observable<OndatoSDK.GroupedObservable<Key, Self.Element>> where Key : Swift.Hashable
}
public protocol SectionedViewDataSourceType {
  func model(at indexPath: Foundation.IndexPath) throws -> Any
}
public enum ColorFormatDenominator {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: OndatoSDK.ColorFormatDenominator, b: OndatoSDK.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Color {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: OndatoSDK.ColorFormatDenominator = .One)
}
@available(iOS 13, macOS 10.15, *)
public enum NFCPassportReaderError : Swift.Error {
  case ResponseError(Swift.String, Swift.UInt8, Swift.UInt8)
  case InvalidResponse
  case UnexpectedError
  case NFCNotSupported
  case NoConnectedTag
  case D087Malformed
  case InvalidResponseChecksum
  case MissingMandatoryFields
  case CannotDecodeASN1Length
  case InvalidASN1Value
  case UnableToProtectAPDU
  case UnableToUnprotectAPDU
  case UnsupportedDataGroup
  case DataGroupNotRead
  case UnknownTag
  case UnknownImageFormat
  case NotImplemented
  case TagNotValid
  case ConnectionError
  case UserCanceled
  case InvalidMRZKey
  case MoreThanOneTagFound
  case InvalidHashAlgorithmSpecified
  case InvalidDataPassed(Swift.String)
  case NotYetSupported(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.NFCPassportReaderError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum OpenSSLError : Swift.Error {
  case UnableToGetX509CertificateFromPKCS7(Swift.String)
  case UnableToVerifyX509CertificateForSOD(Swift.String)
  case VerifyAndReturnSODEncapsulatedData(Swift.String)
  case UnableToReadECPublicKey(Swift.String)
  case UnableToExtractSignedDataFromPKCS7(Swift.String)
  case VerifySignedAttributes(Swift.String)
  case UnableToParseASN1(Swift.String)
  case UnableToDecryptRSASignature(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.OpenSSLError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum PassiveAuthenticationError : Swift.Error {
  case UnableToParseSODHashes(Swift.String)
  case InvalidDataGroupHash(Swift.String)
  case SODMissing(Swift.String)
}
extension OndatoSDK.PassiveAuthenticationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public typealias Signal<Element> = OndatoSDK.SharedSequence<OndatoSDK.SignalSharingStrategy, Element>
public struct SignalSharingStrategy : OndatoSDK.SharingStrategyProtocol {
  public static var scheduler: any OndatoSDK.SchedulerType {
    get
  }
  public static func share<Element>(_ source: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.SignalSharingStrategy {
  public func asSignal() -> OndatoSDK.Signal<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func withUnretained<Object, Out>(_ obj: Object, resultSelector: @escaping (Object, Self.Element) -> Out) -> OndatoSDK.Observable<Out> where Object : AnyObject
  public func withUnretained<Object>(_ obj: Object) -> OndatoSDK.Observable<(Object, Self.Element)> where Object : AnyObject
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
public class BundleImageProvider : OndatoSDK.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?)
  public func imageForAsset(asset: OndatoSDK.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
public protocol ObserverType {
  associatedtype Element
  func on(_ event: OndatoSDK.Event<Self.Element>)
}
extension OndatoSDK.ObserverType {
  public func onNext(_ element: Self.Element)
  public func onCompleted()
  public func onError(_ error: any Swift.Error)
}
extension OndatoSDK.ObservableType {
  public static func create(_ subscribe: @escaping (OndatoSDK.AnyObserver<Self.Element>) -> any OndatoSDK.Disposable) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UISegmentedControl {
  public var selectedSegmentIndex: OndatoSDK.ControlProperty<Swift.Int> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.Int> {
    get
  }
  public func enabledForSegment(at index: Swift.Int) -> OndatoSDK.Binder<Swift.Bool>
  public func titleForSegment(at index: Swift.Int) -> OndatoSDK.Binder<Swift.String?>
  public func imageForSegment(at index: Swift.Int) -> OndatoSDK.Binder<UIKit.UIImage?>
}
extension OndatoSDK.ObservableType {
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind<Object>(with object: Object, onNext: @escaping (Object, Self.Element) -> Swift.Void) -> any OndatoSDK.Disposable where Object : AnyObject
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> any OndatoSDK.Disposable
}
@objc @available(iOS 13, *)
public class PassportReader : ObjectiveC.NSObject {
  public var passiveAuthenticationUsesOpenSSL: Swift.Bool
  public init(logLevel: OndatoSDK.LogLevel = .info, masterListURL: Foundation.URL? = nil)
  public func setMasterListURL(_ masterListURL: Foundation.URL)
  public func overrideNFCDataAmountToRead(amount: Swift.Int)
  public func readPassport(mrzKey: Swift.String, tags: [OndatoSDK.DataGroupId] = [], skipSecureElements: Swift.Bool = true, skipCA: Swift.Bool = false, skipPACE: Swift.Bool = false, customDisplayMessage: ((OndatoSDK.NFCViewDisplayMessage) -> Swift.String?)? = nil, completed: @escaping (OndatoSDK.NFCPassportModel?, OndatoSDK.NFCPassportReaderError?) -> ())
  @objc deinit
}
@available(iOS 13, *)
extension OndatoSDK.PassportReader : CoreNFC.NFCTagReaderSessionDelegate {
  public func tagReaderSessionDidBecomeActive(_ session: CoreNFC.NFCTagReaderSession)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didInvalidateWithError error: any Swift.Error)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didDetect tags: [CoreNFC.NFCTag])
}
extension OndatoSDK.ObservableType {
  public func take(_ count: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func take(for duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "take(for:scheduler:)")
  public func take(_ duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup2 : OndatoSDK.DataGroup {
  public var nrImages: Swift.Int {
    get
  }
  public var versionNumber: Swift.Int {
    get
  }
  public var lengthOfRecord: Swift.Int {
    get
  }
  public var numberOfFacialImages: Swift.Int {
    get
  }
  public var facialRecordDataLength: Swift.Int {
    get
  }
  public var nrFeaturePoints: Swift.Int {
    get
  }
  public var gender: Swift.Int {
    get
  }
  public var eyeColor: Swift.Int {
    get
  }
  public var hairColor: Swift.Int {
    get
  }
  public var featureMask: Swift.Int {
    get
  }
  public var expression: Swift.Int {
    get
  }
  public var poseAngle: Swift.Int {
    get
  }
  public var poseAngleUncertainty: Swift.Int {
    get
  }
  public var faceImageType: Swift.Int {
    get
  }
  public var imageDataType: Swift.Int {
    get
  }
  public var imageWidth: Swift.Int {
    get
  }
  public var imageHeight: Swift.Int {
    get
  }
  public var imageColorSpace: Swift.Int {
    get
  }
  public var sourceType: Swift.Int {
    get
  }
  public var deviceType: Swift.Int {
    get
  }
  public var quality: Swift.Int {
    get
  }
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
extension OndatoSDK.AnimationView {
  @_Concurrency.MainActor(unsafe) convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, animationCache: (any OndatoSDK.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor(unsafe) convenience public init(filePath: Swift.String, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, animationCache: (any OndatoSDK.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor(unsafe) convenience public init(url: Foundation.URL, imageProvider: (any OndatoSDK.AnimationImageProvider)? = nil, closure: @escaping OndatoSDK.AnimationView.DownloadClosure, animationCache: (any OndatoSDK.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
public enum MRZFormat : Swift.CaseIterable {
  case td1, td2, td3
  public var lineLength: Swift.Int {
    get
  }
  public var linesCount: Swift.Int {
    get
  }
  public static func == (a: OndatoSDK.MRZFormat, b: OndatoSDK.MRZFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [OndatoSDK.MRZFormat]
  public static var allCases: [OndatoSDK.MRZFormat] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public struct MRZResult : Swift.Hashable {
  public enum DocumentType : Swift.CaseIterable {
    case visa
    case passport
    case id
    case residencePermit
    case undefined
    public static func == (a: OndatoSDK.MRZResult.DocumentType, b: OndatoSDK.MRZResult.DocumentType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [OndatoSDK.MRZResult.DocumentType]
    public static var allCases: [OndatoSDK.MRZResult.DocumentType] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Sex : Swift.CaseIterable {
    case male
    case female
    case unspecified
    public static func == (a: OndatoSDK.MRZResult.Sex, b: OndatoSDK.MRZResult.Sex) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [OndatoSDK.MRZResult.Sex]
    public static var allCases: [OndatoSDK.MRZResult.Sex] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public let format: OndatoSDK.MRZFormat
  public let documentType: OndatoSDK.MRZResult.DocumentType
  public let countryCode: Swift.String
  public let surnames: Swift.String
  public let givenNames: Swift.String
  public let documentNumber: Swift.String?
  public let nationalityCountryCode: Swift.String
  public let birthdate: Foundation.Date?
  public let sex: OndatoSDK.MRZResult.Sex
  public let expiryDate: Foundation.Date?
  public let optionalData: Swift.String?
  public let optionalData2: Swift.String?
  public var documentImage: UIKit.UIImage?
  public init(format: OndatoSDK.MRZFormat, documentType: OndatoSDK.MRZResult.DocumentType, countryCode: Swift.String, surnames: Swift.String, givenNames: Swift.String, documentNumber: Swift.String?, nationalityCountryCode: Swift.String, birthdate: Foundation.Date?, sex: OndatoSDK.MRZResult.Sex, expiryDate: Foundation.Date?, optionalData: Swift.String?, optionalData2: Swift.String?)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OndatoSDK.MRZResult, b: OndatoSDK.MRZResult) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> OndatoSDK.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension OndatoSDK.SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.SharedSequenceConvertibleType, O2 : OndatoSDK.SharedSequenceConvertibleType, O3 : OndatoSDK.SharedSequenceConvertibleType, O4 : OndatoSDK.SharedSequenceConvertibleType, O5 : OndatoSDK.SharedSequenceConvertibleType, O6 : OndatoSDK.SharedSequenceConvertibleType, O7 : OndatoSDK.SharedSequenceConvertibleType, O8 : OndatoSDK.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
public protocol RxTableViewDataSourceType {
  associatedtype Element
  func tableView(_ tableView: UIKit.UITableView, observedEvent: OndatoSDK.Event<Self.Element>)
}
extension OndatoSDK.ObservableConvertibleType {
  public func asInfallible(onErrorJustReturn element: Self.Element) -> OndatoSDK.Infallible<Self.Element>
  public func asInfallible(onErrorFallbackTo infallible: OndatoSDK.Infallible<Self.Element>) -> OndatoSDK.Infallible<Self.Element>
  public func asInfallible(onErrorRecover: @escaping (any Swift.Error) -> OndatoSDK.Infallible<Self.Element>) -> OndatoSDK.Infallible<Self.Element>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup14 : OndatoSDK.DataGroup {
  public var securityInfos: [OndatoSDK.SecurityInfo] {
    get
  }
  @objc deinit
}
public class HistoricalScheduler : OndatoSDK.VirtualTimeScheduler<OndatoSDK.HistoricalSchedulerTimeConverter> {
  public init(initialClock: OndatoSDK.RxTime = Date(timeIntervalSince1970: 0))
  @objc deinit
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  public func andThen<Element>(_ second: OndatoSDK.Single<Element>) -> OndatoSDK.Single<Element>
  public func andThen<Element>(_ second: OndatoSDK.Maybe<Element>) -> OndatoSDK.Maybe<Element>
  public func andThen(_ second: OndatoSDK.Completable) -> OndatoSDK.Completable
  public func andThen<Element>(_ second: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.Disposables {
  public static func create(with dispose: @escaping () -> Swift.Void) -> any OndatoSDK.Cancelable
}
public enum AnyValue {
  case double(Swift.Double?)
  case int(Swift.Int?)
  case uint64(Swift.UInt64?)
  case string(Swift.String?)
  case bool(Swift.Bool?)
  case object((any Swift.Encodable)?)
  case null
  indirect case array([OndatoSDK.AnyValue]?)
  indirect case dictionary([Swift.String : OndatoSDK.AnyValue]?)
}
extension OndatoSDK.AnyValue : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByNilLiteral {
  public init(nilLiteral: ())
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public init(_ string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = OndatoSDK.AnyValue
  public init(arrayLiteral elements: OndatoSDK.AnyValue...)
}
extension OndatoSDK.AnyValue : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.String
  public typealias Value = OndatoSDK.AnyValue
  public init(dictionaryLiteral elements: (Swift.String, OndatoSDK.AnyValue)...)
}
extension Swift.Dictionary where Key == Swift.String, Value == OndatoSDK.AnyValue {
  public func toStringKeyAndRemoveNilObjects() -> [Swift.String : OndatoSDK.AnyValue]
}
@available(iOS 8.0, macOS 10.10, macOSApplicationExtension 10.10, *)
extension OndatoSDK.Reactive where Base : WebKit.WKWebView {
  public var navigationDelegate: OndatoSDK.DelegateProxy<WebKit.WKWebView, any WebKit.WKNavigationDelegate> {
    get
  }
  public var didCommit: OndatoSDK.Observable<WebKit.WKNavigation> {
    get
  }
  public var didStartLoad: OndatoSDK.Observable<WebKit.WKNavigation> {
    get
  }
  public var didFinishLoad: OndatoSDK.Observable<WebKit.WKNavigation> {
    get
  }
  public var didFailLoad: OndatoSDK.Observable<(WebKit.WKNavigation, any Swift.Error)> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UITextView {
  public var text: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var attributedText: OndatoSDK.ControlProperty<Foundation.NSAttributedString?> {
    get
  }
  public var didBeginEditing: OndatoSDK.ControlEvent<()> {
    get
  }
  public var didEndEditing: OndatoSDK.ControlEvent<()> {
    get
  }
  public var didChange: OndatoSDK.ControlEvent<()> {
    get
  }
  public var didChangeSelection: OndatoSDK.ControlEvent<()> {
    get
  }
}
extension OndatoSDK.ObservableType {
  @available(*, deprecated, renamed: "element(at:)")
  public func elementAt(_ index: Swift.Int) -> OndatoSDK.Observable<Self.Element>
  public func element(at index: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func `do`(onNext: ((Self.Element) throws -> Swift.Void)? = nil, afterNext: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onCompleted: (() throws -> Swift.Void)? = nil, afterCompleted: (() throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Observable<Self.Element>
}
public protocol InfallibleType : OndatoSDK.ObservableConvertibleType {
}
public struct Infallible<Element> : OndatoSDK.InfallibleType {
  public func asObservable() -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.InfallibleType {
  public func subscribe<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func subscribe(_ on: @escaping (OndatoSDK.Event<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
}
final public class ScheduledDisposable : OndatoSDK.Cancelable {
  final public let scheduler: any OndatoSDK.ImmediateSchedulerType
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(scheduler: any OndatoSDK.ImmediateSchedulerType, disposable: any OndatoSDK.Disposable)
  final public func dispose()
  @objc deinit
}
extension OndatoSDK.Color : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.ObservableType {
  public func skip(_ count: Swift.Int) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func skip(_ duration: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableConvertibleType {
  public func asSignal(onErrorJustReturn: Self.Element) -> OndatoSDK.Signal<Self.Element>
  public func asSignal(onErrorSignalWith: OndatoSDK.Signal<Self.Element>) -> OndatoSDK.Signal<Self.Element>
  public func asSignal(onErrorRecover: @escaping (_ error: any Swift.Error) -> OndatoSDK.Signal<Self.Element>) -> OndatoSDK.Signal<Self.Element>
}
public struct PrimitiveSequence<Trait, Element> {
}
public protocol PrimitiveSequenceType {
  associatedtype Trait
  associatedtype Element
  var primitiveSequence: OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element> { get }
}
extension OndatoSDK.PrimitiveSequence : OndatoSDK.PrimitiveSequenceType {
  public var primitiveSequence: OndatoSDK.PrimitiveSequence<Trait, Element> {
    get
  }
}
extension OndatoSDK.PrimitiveSequence : OndatoSDK.ObservableConvertibleType {
  public func asObservable() -> OndatoSDK.Observable<Element>
}
extension OndatoSDK.PrimitiveSequence {
  public static func deferred(_ observableFactory: @escaping () throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func delay(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func delaySubscription(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func observe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "observe(on:)")
  public func observeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func subscribe(on scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "subscribe(on:)")
  public func subscribeOn(_ scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  @available(*, deprecated, renamed: "catch(_:)")
  public func catchError(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func `catch`(_ handler: @escaping (any Swift.Error) throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func retry(_ maxAttemptCount: Swift.Int) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func retry<TriggerObservable, Error>(when notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  public func retry<TriggerObservable>(when notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.PrimitiveSequence<Trait, Element> where TriggerObservable : OndatoSDK.ObservableType
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public static func using<Resource>(_ resourceFactory: @escaping () throws -> Resource, primitiveSequenceFactory: @escaping (Resource) throws -> OndatoSDK.PrimitiveSequence<Trait, Element>) -> OndatoSDK.PrimitiveSequence<Trait, Element> where Resource : OndatoSDK.Disposable
  public func timeout(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
  public func timeout(_ dueTime: OndatoSDK.RxTimeInterval, other: OndatoSDK.PrimitiveSequence<Trait, Element>, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Trait, Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
}
extension OndatoSDK.ObservableType {
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func ignoreElements() -> OndatoSDK.Observable<Swift.Never>
}
extension OndatoSDK.SharedSequenceConvertibleType where Self.SharingStrategy == OndatoSDK.SignalSharingStrategy {
  public func emit<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func emit<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func emit(to relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.PublishRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.PublishRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func emit(to relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func emit<Object>(with object: Object, onNext: ((Object, Self.Element) -> Swift.Void)? = nil, onCompleted: ((Object) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func emit(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func emit() -> any OndatoSDK.Disposable
}
@available(iOS 13, macOS 10.15, *)
public class ASN1Item : Swift.CustomDebugStringConvertible {
  public init(line: Swift.String)
  public func getChild(_ child: Swift.Int) -> OndatoSDK.ASN1Item?
  public func getNumberOfChildren() -> Swift.Int
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class SimpleASN1DumpParser {
  public init()
  public func parse(data: Foundation.Data) throws -> OndatoSDK.ASN1Item
  public func test()
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.NSTextStorage {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.NSTextStorage, any UIKit.NSTextStorageDelegate> {
    get
  }
  public var didProcessEditingRangeChangeInLength: OndatoSDK.Observable<(editedMask: UIKit.NSTextStorage.EditActions, editedRange: Foundation.NSRange, delta: Swift.Int)> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.ObservableConvertibleType {
  public var values: _Concurrency.AsyncThrowingStream<Self.Element, any Swift.Error> {
    get
  }
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension _Concurrency.AsyncSequence {
  public func asObservable() -> OndatoSDK.Observable<Self.Element>
}
#endif
extension OndatoSDK.ObservableType {
  public func scan<A>(into seed: A, accumulator: @escaping (inout A, Self.Element) throws -> Swift.Void) -> OndatoSDK.Observable<A>
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) throws -> A) -> OndatoSDK.Observable<A>
}
public enum LogLevel : Swift.Int, Swift.CaseIterable {
  case verbose
  case debug
  case info
  case warning
  case error
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [OndatoSDK.LogLevel]
  public typealias RawValue = Swift.Int
  public static var allCases: [OndatoSDK.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Log {
  public static var logLevel: OndatoSDK.LogLevel
  public static var storeLogs: Swift.Bool
  public static var logData: [Swift.String]
  public class func verbose(_ msg: @autoclosure () -> Swift.String)
  public class func debug(_ msg: @autoclosure () -> Swift.String)
  public class func info(_ msg: @autoclosure () -> Swift.String)
  public class func warning(_ msg: @autoclosure () -> Swift.String)
  public class func error(_ msg: @autoclosure () -> Swift.String)
  public class func clearStoredLogs()
  @objc deinit
}
extension Swift.Int : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int.KVOType)
}
extension Swift.Int32 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int32.KVOType)
}
extension Swift.Int64 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int64.KVOType)
}
extension Swift.UInt : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt.KVOType)
}
extension Swift.UInt32 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt32.KVOType)
}
extension Swift.UInt64 : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt64.KVOType)
}
extension Swift.Bool : OndatoSDK.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Bool.KVOType)
}
extension OndatoSDK.Reactive where Base : UIKit.UIPickerView {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDelegate> {
    get
  }
  public func setDelegate(_ delegate: any UIKit.UIPickerViewDelegate) -> any OndatoSDK.Disposable
  public var dataSource: OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDataSource> {
    get
  }
  public var itemSelected: OndatoSDK.ControlEvent<(row: Swift.Int, component: Swift.Int)> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<[T]>
  public func itemTitles<Sequence, Source>(_ source: Source) -> (_ titleForRow: @escaping (Swift.Int, Sequence.Element) -> Swift.String?) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func itemAttributedTitles<Sequence, Source>(_ source: Source) -> (_ attributedTitleForRow: @escaping (Swift.Int, Sequence.Element) -> Foundation.NSAttributedString?) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Sequence, Source>(_ source: Source) -> (_ viewForRow: @escaping (Swift.Int, Sequence.Element, UIKit.UIView?) -> UIKit.UIView) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Source, Adapter>(adapter: Adapter) -> (_ source: Source) -> any OndatoSDK.Disposable where Source : OndatoSDK.ObservableType, Adapter : OndatoSDK.RxPickerViewDataSourceType, Adapter : UIKit.UIPickerViewDataSource, Adapter : UIKit.UIPickerViewDelegate, Source.Element == Adapter.Element
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
@_Concurrency.MainActor(unsafe) open class RxTableViewDelegateProxy : OndatoSDK.RxScrollViewDelegateProxy {
  @_Concurrency.MainActor(unsafe) weak public var tableView: UIKit.UITableView? {
    get
  }
  @_Concurrency.MainActor(unsafe) public init(tableView: UIKit.UITableView)
  @objc deinit
}
extension OndatoSDK.RxTableViewDelegateProxy : UIKit.UITableViewDelegate {
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AnimatedButton : OndatoSDK.AnimatedControl {
  @_Concurrency.MainActor(unsafe) override public init(animation: OndatoSDK.Animation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func setPlayRange(fromProgress: OndatoSDK.AnimationProgressTime, toProgress: OndatoSDK.AnimationProgressTime, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor(unsafe) public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UIStepper {
  public var value: OndatoSDK.ControlProperty<Swift.Double> {
    get
  }
}
extension UIKit.UISearchBar : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UISearchBarDelegate
}
open class RxSearchBarDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UISearchBar, any UIKit.UISearchBarDelegate>, OndatoSDK.DelegateProxyType {
  weak public var searchBar: UIKit.UISearchBar? {
    get
  }
  public init(searchBar: OndatoSDK.RxSearchBarDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxSearchBarDelegateProxy : UIKit.UISearchBarDelegate {
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class SecurityInfo {
  public func getObjectIdentifier() -> Swift.String
  public func getProtocolOIDString() -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class LiveMRZScanner {
  public init(frequency: Swift.Int = 2)
  final public func scanFrame(scanningImage: OndatoSDK.ScanningImage, orientation: ImageIO.CGImagePropertyOrientation, regionOfInterest: CoreFoundation.CGRect? = nil, minimumTextHeight: Swift.Float? = nil, foundBoundingRectsHandler: (([CoreFoundation.CGRect]) -> Swift.Void)? = nil, completionHandler: @escaping (Swift.Result<OndatoSDK.DocumentScanningResult<OndatoSDK.ParsedResult>, any Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func take<Source>(until other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
  public func take(until predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Observable<Self.Element>
  public func take(while predicate: @escaping (Self.Element) throws -> Swift.Bool, behavior: OndatoSDK.TakeBehavior = .exclusive) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "take(until:)")
  public func takeUntil<Source>(_ other: Source) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "take(until:behavior:)")
  public func takeUntil(_ behavior: OndatoSDK.TakeBehavior, predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "take(while:)")
  public func takeWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
public enum TakeBehavior {
  case inclusive
  case exclusive
  public static func == (a: OndatoSDK.TakeBehavior, b: OndatoSDK.TakeBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public func AESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESECBEncrypt(key: [Swift.UInt8], message: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@_inheritsConvenienceInitializers final public class SerialDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  final public var disposable: any OndatoSDK.Disposable {
    get
    set(newDisposable)
  }
  final public func dispose()
  @objc deinit
}
@available(iOS 13, *)
public class BACHandler {
  public var ksenc: [Swift.UInt8]
  public var ksmac: [Swift.UInt8]
  public var kifd: [Swift.UInt8]
  public init()
  public init(tagReader: OndatoSDK.TagReader)
  public func performBACAndGetSessionKeys(mrzKey: Swift.String, completed: @escaping (_ error: OndatoSDK.NFCPassportReaderError?) -> ())
  public func sessionKeys(data: [Swift.UInt8]) throws -> ([Swift.UInt8], [Swift.UInt8], [Swift.UInt8])
  @objc deinit
}
@available(iOS 13, *)
public struct ResponseAPDU {
  public var data: [Swift.UInt8]
  public var sw1: Swift.UInt8
  public var sw2: Swift.UInt8
  public init(data: [Swift.UInt8], sw1: Swift.UInt8, sw2: Swift.UInt8)
}
public struct SharedSequence<SharingStrategy, Element> : OndatoSDK.SharedSequenceConvertibleType, OndatoSDK.ObservableConvertibleType where SharingStrategy : OndatoSDK.SharingStrategyProtocol {
  public func asObservable() -> OndatoSDK.Observable<Element>
  public func asSharedSequence() -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
public protocol SharingStrategyProtocol {
  static var scheduler: any OndatoSDK.SchedulerType { get }
  static func share<Element>(_ source: OndatoSDK.Observable<Element>) -> OndatoSDK.Observable<Element>
}
public protocol SharedSequenceConvertibleType : OndatoSDK.ObservableConvertibleType {
  associatedtype SharingStrategy : OndatoSDK.SharingStrategyProtocol
  func asSharedSequence() -> OndatoSDK.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension OndatoSDK.SharedSequenceConvertibleType {
  public func asObservable() -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.SharedSequence {
  public static func empty() -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func never() -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func just(_ element: Element) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func deferred(_ observableFactory: @escaping () -> OndatoSDK.SharedSequence<SharingStrategy, Element>) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func of(_ elements: Element...) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence {
  public static func from(_ array: [Element]) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
  public static func from<Sequence>(_ sequence: Sequence) -> OndatoSDK.SharedSequence<SharingStrategy, Element> where Element == Sequence.Element, Sequence : Swift.Sequence
  public static func from(optional: Element?) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence where Element : Swift.FixedWidthInteger {
  public static func interval(_ period: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.SharedSequence where Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval) -> OndatoSDK.SharedSequence<SharingStrategy, Element>
}
extension OndatoSDK.ObservableType {
  public func single() -> OndatoSDK.Observable<Self.Element>
  public func single(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
@available(iOS 13, *)
public class PACEHandler {
  public init(cardAccess: OndatoSDK.CardAccess, tagReader: OndatoSDK.TagReader) throws
  public func doPACE(mrzKey: Swift.String, completed: @escaping (Swift.Bool) -> ())
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class NotImplementedDG : OndatoSDK.DataGroup {
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : OndatoSDK.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public typealias ScannedBoundingRects = (valid: [CoreFoundation.CGRect], invalid: [CoreFoundation.CGRect])
public struct DocumentScanningResult<T> {
  public let result: T
  public let boundingRects: OndatoSDK.ScannedBoundingRects
}
@dynamicMemberLookup public struct Reactive<Base> {
  public let base: Base
  public init(_ base: Base)
  public subscript<Property>(dynamicMember keyPath: Swift.ReferenceWritableKeyPath<Base, Property>) -> OndatoSDK.Binder<Property> where Base : AnyObject {
    get
  }
}
public protocol ReactiveCompatible {
  associatedtype ReactiveBase
  static var rx: OndatoSDK.Reactive<Self.ReactiveBase>.Type { get set }
  var rx: OndatoSDK.Reactive<Self.ReactiveBase> { get set }
}
extension OndatoSDK.ReactiveCompatible {
  public static var rx: OndatoSDK.Reactive<Self>.Type {
    get
    set
  }
  public var rx: OndatoSDK.Reactive<Self> {
    get
    set
  }
}
extension ObjectiveC.NSObject : OndatoSDK.ReactiveCompatible {
  public typealias ReactiveBase = ObjectiveC.NSObject
}
extension OndatoSDK.Disposable {
  public func disposed(by bag: OndatoSDK.DisposeBag)
}
@_inheritsConvenienceInitializers final public class DisposeBag : OndatoSDK.DisposeBase {
  public init()
  final public func insert(_ disposable: any OndatoSDK.Disposable)
  @objc deinit
}
extension OndatoSDK.DisposeBag {
  convenience public init(disposing disposables: any OndatoSDK.Disposable...)
  convenience public init(@OndatoSDK.DisposeBag.DisposableBuilder builder: () -> [any OndatoSDK.Disposable])
  convenience public init(disposing disposables: [any OndatoSDK.Disposable])
  final public func insert(_ disposables: any OndatoSDK.Disposable...)
  final public func insert(@OndatoSDK.DisposeBag.DisposableBuilder builder: () -> [any OndatoSDK.Disposable])
  final public func insert(_ disposables: [any OndatoSDK.Disposable])
  @_functionBuilder public struct DisposableBuilder {
    public static func buildBlock(_ disposables: any OndatoSDK.Disposable...) -> [any OndatoSDK.Disposable]
  }
}
extension OndatoSDK.ObservableType {
  public static func just(_ element: Self.Element) -> OndatoSDK.Observable<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public static func of(_ elements: Self.Element..., scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public static func from(_ array: [Self.Element], scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element>
  public static func from<Sequence>(_ sequence: Sequence, scheduler: any OndatoSDK.ImmediateSchedulerType = CurrentThreadScheduler.instance) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Self.Element == Sequence.Element
}
extension OndatoSDK.ObservableType {
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
  public func flatMapLatest<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Infallible<Source.Element> where Source : OndatoSDK.InfallibleType
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.ObservableConvertibleType {
  public func switchLatest() -> OndatoSDK.Observable<Self.Element.Element>
}
public func binToHexRep(_ val: [Swift.UInt8], asArray: Swift.Bool = false) -> Swift.String
public func binToHexRep(_ val: Swift.UInt8) -> Swift.String
public func binToHex(_ val: Swift.UInt8) -> Swift.Int
public func binToHex(_ val: [Swift.UInt8]) -> Swift.UInt64
public func binToHex(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.UInt64
public func hexToBin(_ val: Swift.UInt64) -> [Swift.UInt8]
public func binToInt(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.Int
public func binToInt(_ val: [Swift.UInt8]) -> Swift.Int
public func intToBin(_ data: Swift.Int, pad: Swift.Int = 2) -> [Swift.UInt8]
public func hexRepToBin(_ val: Swift.String) -> [Swift.UInt8]
public func xor(_ kifd: [Swift.UInt8], _ response_kicc: [Swift.UInt8]) -> [Swift.UInt8]
public func generateRandomUInt8Array(_ size: Swift.Int) -> [Swift.UInt8]
public func pad(_ toPad: [Swift.UInt8], blockSize: Swift.Int) -> [Swift.UInt8]
public func unpad(_ tounpad: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func mac(algoName: OndatoSDK.SecureMessagingSupportedAlgorithms, key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func desMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func aesMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func wrapDO(b: Swift.UInt8, arr: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func unwrapDO(tag: Swift.UInt8, wrappedData: [Swift.UInt8]) throws -> [Swift.UInt8]
public func intToBytes(val: Swift.Int, removePadding: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func oidToBytes(oid: Swift.String, replaceTag: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: Swift.ArraySlice<Swift.UInt8>) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: [Swift.UInt8]) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func toAsn1Length(_ data: Swift.Int) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcHash(data: [Swift.UInt8], hashAlgorithm: Swift.String) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA1Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA224Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA256Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA512Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA384Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
extension OndatoSDK.ObservableType {
  public static func amb<Sequence>(_ sequence: Sequence) -> OndatoSDK.Observable<Self.Element> where Sequence : Swift.Sequence, Sequence.Element == OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func amb<O2>(_ right: O2) -> OndatoSDK.Observable<Self.Element> where O2 : OndatoSDK.ObservableType, Self.Element == O2.Element
}
extension UIKit.UIPickerView : OndatoSDK.HasDataSource {
  public typealias DataSource = UIKit.UIPickerViewDataSource
}
public class RxPickerViewDataSourceProxy : OndatoSDK.DelegateProxy<UIKit.UIPickerView, any UIKit.UIPickerViewDataSource>, OndatoSDK.DelegateProxyType {
  weak public var pickerView: UIKit.UIPickerView? {
    get
  }
  public init(pickerView: OndatoSDK.RxPickerViewDataSourceProxy.ParentObject)
  public static func registerKnownImplementations()
  override public func setForwardToDelegate(_ forwardToDelegate: (any UIKit.UIPickerViewDataSource)?, retainDelegate: Swift.Bool)
  @objc deinit
}
extension OndatoSDK.RxPickerViewDataSourceProxy : UIKit.UIPickerViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
}
extension OndatoSDK.ObservableType {
  public static func combineLatest<Collection>(_ collection: Collection, resultSelector: @escaping ([Collection.Element.Element]) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element : OndatoSDK.ObservableType
  public static func combineLatest<Collection>(_ collection: Collection) -> OndatoSDK.Observable<[Self.Element]> where Collection : Swift.Collection, Self.Element == Collection.Element.Element, Collection.Element : OndatoSDK.ObservableType
}
public typealias RxTimeInterval = Dispatch.DispatchTimeInterval
public typealias RxTime = Foundation.Date
public protocol SchedulerType : OndatoSDK.ImmediateSchedulerType {
  var now: OndatoSDK.RxTime { get }
  func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
}
extension OndatoSDK.SchedulerType {
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class OndatoLog : ObjectiveC.NSObject {
  public static let shared: OndatoSDK.OndatoLog
  public var logs: [Swift.String] {
    get
  }
  @objc deinit
}
public class LRUAnimationCache : OndatoSDK.AnimationCacheProvider {
  public init()
  public static let sharedCache: OndatoSDK.LRUAnimationCache
  public var cacheSize: Swift.Int
  public func clearCache()
  public func animation(forKey: Swift.String) -> OndatoSDK.Animation?
  public func setAnimation(_ animation: OndatoSDK.Animation, forKey: Swift.String)
  @objc deinit
}
public enum Hooks {
  public static var recordCallStackOnError: Swift.Bool
}
@_hasMissingDesignatedInitializers public class SerialDispatchQueueScheduler : OndatoSDK.SchedulerType {
  public typealias TimeInterval = Foundation.TimeInterval
  public typealias Time = Foundation.Date
  public var now: Foundation.Date {
    get
  }
  convenience public init(internalSerialQueueName: Swift.String, serialQueueConfiguration: ((Dispatch.DispatchQueue) -> Swift.Void)? = nil, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  convenience public init(queue: Dispatch.DispatchQueue, internalSerialQueueName: Swift.String, leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  @available(macOS 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS, internalSerialQueueName: Swift.String = "rx.global_dispatch_queue.serial", leeway: Dispatch.DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0))
  final public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  final public func scheduleRelative<StateType>(_ state: StateType, dueTime: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  public func schedulePeriodic<StateType>(_ state: StateType, startAfter: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval, action: @escaping (StateType) -> StateType) -> any OndatoSDK.Disposable
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum DocTypeEnum : Swift.String {
  case TD1
  case TD2
  case OTHER
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup1 : OndatoSDK.DataGroup {
  public var elements: [Swift.String : Swift.String] {
    get
  }
  @objc deinit
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2>(_ source1: I1, _ source2: I2, resultSelector: @escaping (I1.Element, I2.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3>(_ source1: I1, _ source2: I2, _ source3: I3, resultSelector: @escaping (I1.Element, I2.Element, I3.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5, I6>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, _ source6: I6, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element, I6.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType, I6 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5, I6, I7>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, _ source6: I6, _ source7: I7, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element, I6.Element, I7.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType, I6 : OndatoSDK.InfallibleType, I7 : OndatoSDK.InfallibleType
}
extension OndatoSDK.Infallible {
  public static func combineLatest<I1, I2, I3, I4, I5, I6, I7, I8>(_ source1: I1, _ source2: I2, _ source3: I3, _ source4: I4, _ source5: I5, _ source6: I6, _ source7: I7, _ source8: I8, resultSelector: @escaping (I1.Element, I2.Element, I3.Element, I4.Element, I5.Element, I6.Element, I7.Element, I8.Element) throws -> Element) -> OndatoSDK.Infallible<Element> where I1 : OndatoSDK.InfallibleType, I2 : OndatoSDK.InfallibleType, I3 : OndatoSDK.InfallibleType, I4 : OndatoSDK.InfallibleType, I5 : OndatoSDK.InfallibleType, I6 : OndatoSDK.InfallibleType, I7 : OndatoSDK.InfallibleType, I8 : OndatoSDK.InfallibleType
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup12 : OndatoSDK.DataGroup {
  public var issuingAuthority: Swift.String? {
    get
  }
  public var dateOfIssue: Swift.String? {
    get
  }
  public var otherPersonsDetails: Swift.String? {
    get
  }
  public var endorsementsOrObservations: Swift.String? {
    get
  }
  public var taxOrExitRequirements: Swift.String? {
    get
  }
  public var frontImage: [Swift.UInt8]? {
    get
  }
  public var rearImage: [Swift.UInt8]? {
    get
  }
  public var personalizationTime: Swift.String? {
    get
  }
  public var personalizationDeviceSerialNr: Swift.String? {
    get
  }
  @objc deinit
}
public protocol ControlPropertyType : OndatoSDK.ObservableType, OndatoSDK.ObserverType {
  func asControlProperty() -> OndatoSDK.ControlProperty<Self.Element>
}
public struct ControlProperty<PropertyType> : OndatoSDK.ControlPropertyType {
  public typealias Element = PropertyType
  public init<Values, Sink>(values: Values, valueSink: Sink) where PropertyType == Values.Element, Values : OndatoSDK.ObservableType, Sink : OndatoSDK.ObserverType, Values.Element == Sink.Element
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where PropertyType == Observer.Element, Observer : OndatoSDK.ObserverType
  public var changed: OndatoSDK.ControlEvent<PropertyType> {
    get
  }
  public func asObservable() -> OndatoSDK.Observable<OndatoSDK.ControlProperty<PropertyType>.Element>
  public func asControlProperty() -> OndatoSDK.ControlProperty<OndatoSDK.ControlProperty<PropertyType>.Element>
  public func on(_ event: OndatoSDK.Event<OndatoSDK.ControlProperty<PropertyType>.Element>)
}
extension OndatoSDK.ControlPropertyType where Self.Element == Swift.String? {
  public var orEmpty: OndatoSDK.ControlProperty<Swift.String> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIControl {
  public func controlEvent(_ controlEvents: UIKit.UIControl.Event) -> OndatoSDK.ControlEvent<()>
  public func controlProperty<T>(editingEvents: UIKit.UIControl.Event, getter: @escaping (Base) -> T, setter: @escaping (Base, T) -> Swift.Void) -> OndatoSDK.ControlProperty<T>
}
public enum SecureMessagingSupportedAlgorithms {
  case DES
  case AES
  public static func == (a: OndatoSDK.SecureMessagingSupportedAlgorithms, b: OndatoSDK.SecureMessagingSupportedAlgorithms) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, *)
public class SecureMessaging {
  public init(encryptionAlgorithm: OndatoSDK.SecureMessagingSupportedAlgorithms = .DES, ksenc: [Swift.UInt8], ksmac: [Swift.UInt8], ssc: [Swift.UInt8])
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationInfo : OndatoSDK.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class COM : OndatoSDK.DataGroup {
  public var version: Swift.String {
    get
  }
  public var unicodeVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  @objc deinit
}
public protocol ImmediateSchedulerType {
  func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
}
extension OndatoSDK.ImmediateSchedulerType {
  public func scheduleRecursive<State>(_ state: State, action: @escaping (_ state: State, _ recurse: (State) -> Swift.Void) -> Swift.Void) -> any OndatoSDK.Disposable
}
extension OndatoSDK.ControlEvent {
  public func asSignal() -> OndatoSDK.Signal<OndatoSDK.ControlEvent<PropertyType>.Element>
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class OpenSSLUtils {
  public static func getOpenSSLError() -> Swift.String
  @available(iOS 13, macOS 10.15, *)
  public static func getPublicKeyData(from key: Swift.OpaquePointer) -> [Swift.UInt8]?
  @available(iOS 13, macOS 10.15, *)
  public static func decodePublicKeyFromBytes(pubKeyData: [Swift.UInt8], params: Swift.OpaquePointer) -> Swift.OpaquePointer?
  public static func computeSharedSecret(privateKeyPair: Swift.OpaquePointer, publicKey: Swift.OpaquePointer) -> [Swift.UInt8]
  @objc deinit
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) public class OndatoViewController : UIKit.UIPageViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(transitionStyle style: UIKit.UIPageViewController.TransitionStyle, navigationOrientation: UIKit.UIPageViewController.NavigationOrientation, options: [UIKit.UIPageViewController.OptionsKey : Any]? = nil)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class BehaviorSubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.ObserverType, OndatoSDK.Cancelable {
  public typealias SubjectObserverType = OndatoSDK.BehaviorSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(value: Element)
  final public func value() throws -> Element
  final public func on(_ event: OndatoSDK.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObserver() -> OndatoSDK.BehaviorSubject<Element>
  final public func dispose()
  public typealias Observer = OndatoSDK.BehaviorSubject<Element>
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UINavigationController {
  public typealias ShowEvent = (viewController: UIKit.UIViewController, animated: Swift.Bool)
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UINavigationController, any UIKit.UINavigationControllerDelegate> {
    get
  }
  public var willShow: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.ShowEvent> {
    get
  }
  public var didShow: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.ShowEvent> {
    get
  }
}
@objc(OndatoServerMode) public enum OndatoEnvironment : Swift.Int {
  case test = 0
  case live = 1
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func withLatestFrom<Source, ResultType>(_ second: Source, resultSelector: @escaping (Self.Element, Source.Element) throws -> ResultType) -> OndatoSDK.Observable<ResultType> where Source : OndatoSDK.ObservableConvertibleType
  public func withLatestFrom<Source>(_ second: Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
public enum PACEMappingType {
  case GM
  case IM
  case CAM
  public static func == (a: OndatoSDK.PACEMappingType, b: OndatoSDK.PACEMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class PACEInfo : OndatoSDK.SecurityInfo {
  public static let PARAM_ID_GFP_1024_160: Swift.Int
  public static let PARAM_ID_GFP_2048_224: Swift.Int
  public static let PARAM_ID_GFP_2048_256: Swift.Int
  public static let PARAM_ID_ECP_NIST_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P320_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P512_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P521_R1: Swift.Int
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getVersion() -> Swift.Int
  public func getParameterId() -> Swift.Int?
  public func getParameterSpec() throws -> Swift.Int32
  public func getMappingType() throws -> OndatoSDK.PACEMappingType
  public func getKeyAgreementAlgorithm() throws -> Swift.String
  public func getCipherAlgorithm() throws -> Swift.String
  public func getDigestAlgorithm() throws -> Swift.String
  public func getKeyLength() throws -> Swift.Int
  public func createMappingKey() throws -> Swift.OpaquePointer
  public static func getParameterSpec(stdDomainParam: Swift.Int) throws -> Swift.Int32
  public static func toMappingType(oid: Swift.String) throws -> OndatoSDK.PACEMappingType
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toDigestAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func never() -> OndatoSDK.Observable<Self.Element>
}
public class FilepathImageProvider : OndatoSDK.AnimationImageProvider {
  public init(filepath: Swift.String)
  public init(filepath: Foundation.URL)
  public func imageForAsset(asset: OndatoSDK.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public static let modelName: Swift.String
  @_Concurrency.MainActor(unsafe) public static let osVersion: OndatoSDK.OSVersion
}
extension Swift.Encodable {
  public var jsonData: Foundation.Data? {
    get
  }
}
extension UIKit.UINavigationController : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UINavigationControllerDelegate
}
open class RxNavigationControllerDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UINavigationController, any UIKit.UINavigationControllerDelegate>, OndatoSDK.DelegateProxyType {
  weak public var navigationController: UIKit.UINavigationController? {
    get
  }
  public init(navigationController: OndatoSDK.RxNavigationControllerDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxNavigationControllerDelegateProxy : UIKit.UINavigationControllerDelegate {
}
public struct GroupedObservable<Key, Element> : OndatoSDK.ObservableType {
  public let key: Key
  public init(key: Key, source: OndatoSDK.Observable<Element>)
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  public func asObservable() -> OndatoSDK.Observable<Element>
}
public struct Vector1D {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
}
public struct Vector3D {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup7 : OndatoSDK.DataGroup {
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: OndatoSDK.AnimationKeypath
  @objc deinit
}
extension OndatoSDK.ControlEvent {
  public func asDriver() -> OndatoSDK.Driver<OndatoSDK.ControlEvent<PropertyType>.Element>
}
public protocol VirtualTimeConverterType {
  associatedtype VirtualTimeUnit
  associatedtype VirtualTimeIntervalUnit
  func convertFromVirtualTime(_ virtualTime: Self.VirtualTimeUnit) -> OndatoSDK.RxTime
  func convertToVirtualTime(_ time: OndatoSDK.RxTime) -> Self.VirtualTimeUnit
  func convertFromVirtualTimeInterval(_ virtualTimeInterval: Self.VirtualTimeIntervalUnit) -> Foundation.TimeInterval
  func convertToVirtualTimeInterval(_ timeInterval: Foundation.TimeInterval) -> Self.VirtualTimeIntervalUnit
  func offsetVirtualTime(_ time: Self.VirtualTimeUnit, offset: Self.VirtualTimeIntervalUnit) -> Self.VirtualTimeUnit
  func compareVirtualTime(_ lhs: Self.VirtualTimeUnit, _ rhs: Self.VirtualTimeUnit) -> OndatoSDK.VirtualTimeComparison
}
public enum VirtualTimeComparison {
  case lessThan
  case equal
  case greaterThan
  public static func == (a: OndatoSDK.VirtualTimeComparison, b: OndatoSDK.VirtualTimeComparison) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class CurrentThreadScheduler : OndatoSDK.ImmediateSchedulerType {
  public static let instance: OndatoSDK.CurrentThreadScheduler
  public static var isScheduleRequired: Swift.Bool {
    get
  }
  public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> any OndatoSDK.Disposable) -> any OndatoSDK.Disposable
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, *)
public class TagReader {
  @objc deinit
}
extension OndatoSDK.Reactive where Base : Foundation.NotificationCenter {
  public func notification(_ name: Foundation.Notification.Name?, object: Swift.AnyObject? = nil) -> OndatoSDK.Observable<Foundation.Notification>
}
extension OndatoSDK.ObservableType {
  public func retry<TriggerObservable, Error>(when notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable, Error>(_ notificationHandler: @escaping (OndatoSDK.Observable<Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType, Error : Swift.Error
  public func retry<TriggerObservable>(when notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType
  @available(*, deprecated, renamed: "retry(when:)")
  public func retryWhen<TriggerObservable>(_ notificationHandler: @escaping (OndatoSDK.Observable<any Swift.Error>) -> TriggerObservable) -> OndatoSDK.Observable<Self.Element> where TriggerObservable : OndatoSDK.ObservableType
}
extension OndatoSDK.InfallibleType {
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> any OndatoSDK.Disposable where Observer : OndatoSDK.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
}
extension UIKit.UIImage {
  public class func gifImageWithData(_ data: Foundation.Data) -> UIKit.UIImage?
  public class func gifImageWithURL(_ gifUrl: Swift.String) -> UIKit.UIImage?
  public class func gifImageWithName(_ name: Swift.String) -> UIKit.UIImage?
}
extension OndatoSDK.ObservableType {
  public func flatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.ObservableType {
  public func flatMapFirst<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.ObservableConvertibleType {
  public func merge() -> OndatoSDK.Observable<Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> OndatoSDK.Observable<Self.Element.Element>
}
extension OndatoSDK.ObservableType where Self.Element : OndatoSDK.ObservableConvertibleType {
  public func concat() -> OndatoSDK.Observable<Self.Element.Element>
}
extension OndatoSDK.ObservableType {
  public static func merge<Collection>(_ sources: Collection) -> OndatoSDK.Observable<Self.Element> where Collection : Swift.Collection, Collection.Element == OndatoSDK.Observable<Self.Element>
  public static func merge(_ sources: [OndatoSDK.Observable<Self.Element>]) -> OndatoSDK.Observable<Self.Element>
  public static func merge(_ sources: OndatoSDK.Observable<Self.Element>...) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func concatMap<Source>(_ selector: @escaping (Self.Element) throws -> Source) -> OndatoSDK.Observable<Source.Element> where Source : OndatoSDK.ObservableConvertibleType
}
public enum RecognitionLevel {
  case accurate
  case fast
  public static func == (a: OndatoSDK.RecognitionLevel, b: OndatoSDK.RecognitionLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias RxAbstractInteger = Swift.FixedWidthInteger
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.InfallibleType {
  public var values: _Concurrency.AsyncStream<Self.Element> {
    get
  }
}
public struct OSVersion : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OndatoSDK.ObservableType {
  public func skip(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
  @available(*, deprecated, renamed: "skip(while:)")
  public func skipWhile(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Observable<Self.Element>
}
public struct TextInput<Base> where Base : UIKit.UITextInput {
  public let base: Base
  public let text: OndatoSDK.ControlProperty<Swift.String?>
  public init(base: Base, text: OndatoSDK.ControlProperty<Swift.String?>)
}
extension OndatoSDK.Reactive where Base : UIKit.UITextField {
  public var textInput: OndatoSDK.TextInput<Base> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UITextView {
  public var textInput: OndatoSDK.TextInput<Base> {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup {
  public var datagroupType: OndatoSDK.DataGroupId
  public var body: [Swift.UInt8] {
    get
  }
  public var data: [Swift.UInt8] {
    get
  }
  public func hash(_ hashAlgorythm: Swift.String) -> [Swift.UInt8]
  @objc deinit
}
@objc(OndatoFlowDelegate) public protocol OndatoFlowDelegate {
  @objc optional func viewControllerForStart(startPressed: @escaping () -> Swift.Void) -> UIKit.UIViewController
  @objc optional func viewForLoading(progress: Swift.Float) -> UIKit.UIView?
  @objc optional func viewForSuccess(continue: @escaping () -> Swift.Void) -> UIKit.UIView
  @objc func flowDidSucceed(identificationId: Swift.String?)
  @objc func flowDidFail(identificationId: Swift.String?, error: OndatoSDK.OndatoServiceError)
}
extension OndatoSDK.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func interval(_ period: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType where Self.Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: OndatoSDK.RxTimeInterval, period: OndatoSDK.RxTimeInterval? = nil, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.Reactive where Base : UIKit.UIButton {
  public var tap: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UIButton {
  public func title(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<Swift.String?>
  public func image(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<UIKit.UIImage?>
  public func backgroundImage(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<UIKit.UIImage?>
}
extension OndatoSDK.Reactive where Base : UIKit.UIButton {
  public func attributedTitle(for controlState: UIKit.UIControl.State = []) -> OndatoSDK.Binder<Foundation.NSAttributedString?>
}
extension UIKit.UITabBarController : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UITabBarControllerDelegate
}
open class RxTabBarControllerDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UITabBarController, any UIKit.UITabBarControllerDelegate>, OndatoSDK.DelegateProxyType {
  weak public var tabBar: UIKit.UITabBarController? {
    get
  }
  public init(tabBar: OndatoSDK.RxTabBarControllerDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxTabBarControllerDelegateProxy : UIKit.UITabBarControllerDelegate {
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBarController {
  public var willBeginCustomizing: OndatoSDK.ControlEvent<[UIKit.UIViewController]> {
    get
  }
  public var willEndCustomizing: OndatoSDK.ControlEvent<(viewControllers: [UIKit.UIViewController], changed: Swift.Bool)> {
    get
  }
  public var didEndCustomizing: OndatoSDK.ControlEvent<(viewControllers: [UIKit.UIViewController], changed: Swift.Bool)> {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UITabBarController {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UITabBarController, any UIKit.UITabBarControllerDelegate> {
    get
  }
  public var didSelect: OndatoSDK.ControlEvent<UIKit.UIViewController> {
    get
  }
}
public enum SingleTrait {
}
public typealias Single<Element> = OndatoSDK.PrimitiveSequence<OndatoSDK.SingleTrait, Element>
public typealias SingleEvent<Element> = Swift.Result<Element, any Swift.Error>
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public typealias SingleObserver = (OndatoSDK.SingleEvent<Self.Element>) -> Swift.Void
  public static func create(subscribe: @escaping (@escaping Self.SingleObserver) -> any OndatoSDK.Disposable) -> OndatoSDK.Single<Self.Element>
  public func subscribe(_ observer: @escaping (OndatoSDK.SingleEvent<Self.Element>) -> Swift.Void) -> any OndatoSDK.Disposable
  @available(*, deprecated, renamed: "subscribe(onSuccess:onFailure:onDisposed:)")
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onError: @escaping ((any Swift.Error) -> Swift.Void), onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
  public func subscribe<Object>(with object: Object, onSuccess: ((Object, Self.Element) -> Swift.Void)? = nil, onFailure: ((Object, any Swift.Error) -> Swift.Void)? = nil, onDisposed: ((Object) -> Swift.Void)? = nil) -> any OndatoSDK.Disposable where Object : AnyObject
  public func subscribe(onSuccess: ((Self.Element) -> Swift.Void)? = nil, onFailure: ((any Swift.Error) -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> any OndatoSDK.Disposable
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public static func just(_ element: Self.Element) -> OndatoSDK.Single<Self.Element>
  public static func just(_ element: Self.Element, scheduler: any OndatoSDK.ImmediateSchedulerType) -> OndatoSDK.Single<Self.Element>
  public static func error(_ error: any Swift.Error) -> OndatoSDK.Single<Self.Element>
  public static func never() -> OndatoSDK.Single<Self.Element>
}
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  public func `do`(onSuccess: ((Self.Element) throws -> Swift.Void)? = nil, afterSuccess: ((Self.Element) throws -> Swift.Void)? = nil, onError: ((any Swift.Error) throws -> Swift.Void)? = nil, afterError: ((any Swift.Error) throws -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> OndatoSDK.Single<Self.Element>
  public func filter(_ predicate: @escaping (Self.Element) throws -> Swift.Bool) -> OndatoSDK.Maybe<Self.Element>
  public func map<Result>(_ transform: @escaping (Self.Element) throws -> Result) -> OndatoSDK.Single<Result>
  public func compactMap<Result>(_ transform: @escaping (Self.Element) throws -> Result?) -> OndatoSDK.Maybe<Result>
  public func flatMap<Result>(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Single<Result>) -> OndatoSDK.Single<Result>
  public func flatMapMaybe<Result>(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Maybe<Result>) -> OndatoSDK.Maybe<Result>
  public func flatMapCompletable(_ selector: @escaping (Self.Element) throws -> OndatoSDK.Completable) -> OndatoSDK.Completable
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Self.Element]) throws -> Result) -> OndatoSDK.PrimitiveSequence<Self.Trait, Result> where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.SingleTrait, Self.Element>
  public static func zip<Collection>(_ collection: Collection) -> OndatoSDK.PrimitiveSequence<Self.Trait, [Self.Element]> where Collection : Swift.Collection, Collection.Element == OndatoSDK.PrimitiveSequence<OndatoSDK.SingleTrait, Self.Element>
  public func catchAndReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  @available(*, deprecated, renamed: "catchAndReturn(_:)")
  public func catchErrorJustReturn(_ element: Self.Element) -> OndatoSDK.PrimitiveSequence<Self.Trait, Self.Element>
  public func asMaybe() -> OndatoSDK.Maybe<Self.Element>
  public func asCompletable() -> OndatoSDK.Completable
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension OndatoSDK.ObservableConvertibleType {
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorJustReturn: Self.Element) -> OndatoSDK.SharedSequence<S, Self.Element> where S : OndatoSDK.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorDriveWith: OndatoSDK.SharedSequence<S, Self.Element>) -> OndatoSDK.SharedSequence<S, Self.Element> where S : OndatoSDK.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorRecover: @escaping (_ error: any Swift.Error) -> OndatoSDK.SharedSequence<S, Self.Element>) -> OndatoSDK.SharedSequence<S, Self.Element> where S : OndatoSDK.SharingStrategyProtocol
}
@_inheritsConvenienceInitializers @objc(OndatoServiceConfiguration) public class OndatoServiceConfiguration : ObjectiveC.NSObject {
  @objc public var appearance: OndatoSDK.OndatoAppearance
  @objc public var flowConfiguration: OndatoSDK.OndatoFlowConfiguration
  @objc public var mode: OndatoSDK.OndatoEnvironment
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc(OndatoFlowConfiguration) public class OndatoFlowConfiguration : ObjectiveC.NSObject {
  @objc public var showSplashScreen: Swift.Bool
  @objc public var showStartScreen: Swift.Bool
  @objc public var showSuccessWindow: Swift.Bool
  @objc public var removeSelfieFrame: Swift.Bool
  @objc public var skipRegistrationIfDriverLicense: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CompositeDisposable : OndatoSDK.DisposeBase, OndatoSDK.Cancelable {
  public struct DisposeKey {
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  public init()
  public init(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable)
  public init(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable)
  public init(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable, _ disposable4: any OndatoSDK.Disposable, _ disposables: any OndatoSDK.Disposable...)
  public init(disposables: [any OndatoSDK.Disposable])
  final public func insert(_ disposable: any OndatoSDK.Disposable) -> OndatoSDK.CompositeDisposable.DisposeKey?
  final public var count: Swift.Int {
    get
  }
  final public func remove(for disposeKey: OndatoSDK.CompositeDisposable.DisposeKey)
  final public func dispose()
  @objc deinit
}
extension OndatoSDK.Disposables {
  public static func create(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable) -> any OndatoSDK.Cancelable
  public static func create(_ disposable1: any OndatoSDK.Disposable, _ disposable2: any OndatoSDK.Disposable, _ disposable3: any OndatoSDK.Disposable, _ disposables: any OndatoSDK.Disposable...) -> any OndatoSDK.Cancelable
  public static func create(_ disposables: [any OndatoSDK.Disposable]) -> any OndatoSDK.Cancelable
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class LottieView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public protocol SubjectType : OndatoSDK.ObservableType {
  associatedtype Observer : OndatoSDK.ObserverType
  func asObserver() -> Self.Observer
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> OndatoSDK.Observable<(O1.Element, O2.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Self.Element) -> OndatoSDK.Observable<Self.Element> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
extension OndatoSDK.ObservableType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> OndatoSDK.Observable<(O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : OndatoSDK.ObservableType, O2 : OndatoSDK.ObservableType, O3 : OndatoSDK.ObservableType, O4 : OndatoSDK.ObservableType, O5 : OndatoSDK.ObservableType, O6 : OndatoSDK.ObservableType, O7 : OndatoSDK.ObservableType, O8 : OndatoSDK.ObservableType
}
@_hasMissingDesignatedInitializers public class Observable<Element> : OndatoSDK.ObservableType {
  public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  public func asObservable() -> OndatoSDK.Observable<Element>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DisposeBase {
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public func enumerated() -> OndatoSDK.Observable<(index: Swift.Int, element: Self.Element)>
}
public typealias LottieCompletionBlock = (Swift.Bool) -> Swift.Void
@objc(OndatoDocumentType) public enum OndatoDocumentType : Swift.Int, Swift.Codable {
  case passport = 0
  case idCard = 1
  case drivingLicence = 2
  case proofOfAddress = 3
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension OndatoSDK.Reactive where Base : UIKit.UISearchBar {
  public var delegate: OndatoSDK.DelegateProxy<UIKit.UISearchBar, any UIKit.UISearchBarDelegate> {
    get
  }
  public var text: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var selectedScopeButtonIndex: OndatoSDK.ControlProperty<Swift.Int> {
    get
  }
  public var cancelButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var bookmarkButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var resultsListButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var searchButtonClicked: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var textDidBeginEditing: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public var textDidEndEditing: OndatoSDK.ControlEvent<Swift.Void> {
    get
  }
  public func setDelegate(_ delegate: any UIKit.UISearchBarDelegate) -> any OndatoSDK.Disposable
}
public struct AnyObserver<Element> : OndatoSDK.ObserverType {
  public typealias EventHandler = (OndatoSDK.Event<Element>) -> Swift.Void
  public init(eventHandler: @escaping OndatoSDK.AnyObserver<Element>.EventHandler)
  public init<Observer>(_ observer: Observer) where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  public func on(_ event: OndatoSDK.Event<Element>)
  public func asObserver() -> OndatoSDK.AnyObserver<Element>
}
extension OndatoSDK.ObserverType {
  public func asObserver() -> OndatoSDK.AnyObserver<Self.Element>
  public func mapObserver<Result>(_ transform: @escaping (Result) throws -> Self.Element) -> OndatoSDK.AnyObserver<Result>
}
extension OndatoSDK.ObservableType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> OndatoSDK.Observable<Self.Element>
}
extension OndatoSDK.ObservableType {
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.PublishRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.BehaviorRelay<Self.Element?>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element>...) -> any OndatoSDK.Disposable
  public func bind(to relays: OndatoSDK.ReplayRelay<Self.Element?>...) -> any OndatoSDK.Disposable
}
extension OndatoSDK.ObservableType {
  public func ifEmpty(switchTo other: OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(OndatoLocalizeHelper) public class OndatoLocalizeHelper : ObjectiveC.NSObject {
  @objc public static var language: OndatoSDK.OndatoSupportedLanguage
  @objc public static func setLocalizationBundle(_ bundle: OndatoSDK.OndatoLocalizationBundle, for language: OndatoSDK.OndatoSupportedLanguage)
  @objc deinit
}
extension OndatoSDK.ObservableType {
  public static func deferred(_ observableFactory: @escaping () throws -> OndatoSDK.Observable<Self.Element>) -> OndatoSDK.Observable<Self.Element>
}
public protocol RxCollectionViewDataSourceType {
  associatedtype Element
  func collectionView(_ collectionView: UIKit.UICollectionView, observedEvent: OndatoSDK.Event<Self.Element>)
}
extension OndatoSDK.ObservableType {
  public func materialize() -> OndatoSDK.Observable<OndatoSDK.Event<Self.Element>>
}
extension OndatoSDK.ObservableType {
  public func timeout(_ dueTime: OndatoSDK.RxTimeInterval, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element>
  public func timeout<Source>(_ dueTime: OndatoSDK.RxTimeInterval, other: Source, scheduler: any OndatoSDK.SchedulerType) -> OndatoSDK.Observable<Self.Element> where Source : OndatoSDK.ObservableConvertibleType, Self.Element == Source.Element
}
extension UIKit.UIScrollView : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UIScrollViewDelegate
}
open class RxScrollViewDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UIScrollView, any UIKit.UIScrollViewDelegate>, OndatoSDK.DelegateProxyType {
  weak public var scrollView: UIKit.UIScrollView? {
    get
  }
  public init(scrollView: OndatoSDK.RxScrollViewDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  @objc deinit
}
extension OndatoSDK.RxScrollViewDelegateProxy : UIKit.UIScrollViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func scrollViewDidScroll(_ scrollView: UIKit.UIScrollView)
}
extension UIKit.UITabBar : OndatoSDK.HasDelegate {
  public typealias Delegate = UIKit.UITabBarDelegate
}
open class RxTabBarDelegateProxy : OndatoSDK.DelegateProxy<UIKit.UITabBar, any UIKit.UITabBarDelegate>, OndatoSDK.DelegateProxyType {
  weak public var tabBar: UIKit.UITabBar? {
    get
  }
  public init(tabBar: OndatoSDK.RxTabBarDelegateProxy.ParentObject)
  public static func registerKnownImplementations()
  open class func currentDelegate(for object: OndatoSDK.RxTabBarDelegateProxy.ParentObject) -> (any UIKit.UITabBarDelegate)?
  open class func setCurrentDelegate(_ delegate: (any UIKit.UITabBarDelegate)?, to object: OndatoSDK.RxTabBarDelegateProxy.ParentObject)
  @objc deinit
}
extension OndatoSDK.RxTabBarDelegateProxy : UIKit.UITabBarDelegate {
}
@_Concurrency.MainActor(unsafe) open class RxTextViewDelegateProxy : OndatoSDK.RxScrollViewDelegateProxy {
  @_Concurrency.MainActor(unsafe) weak public var textView: UIKit.UITextView? {
    get
  }
  @_Concurrency.MainActor(unsafe) public init(textView: UIKit.UITextView)
  @objc deinit
}
extension OndatoSDK.RxTextViewDelegateProxy : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic open func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
}
extension OndatoSDK.Reactive where Base : UIKit.UICollectionView {
  public func items<Sequence, Source>(_ source: Source) -> (_ cellFactory: @escaping (UIKit.UICollectionView, Swift.Int, Sequence.Element) -> UIKit.UICollectionViewCell) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Source : OndatoSDK.ObservableType
  public func items<Sequence, Cell, Source>(cellIdentifier: Swift.String, cellType: Cell.Type = Cell.self) -> (_ source: Source) -> (_ configureCell: @escaping (Swift.Int, Sequence.Element, Cell) -> Swift.Void) -> any OndatoSDK.Disposable where Sequence : Swift.Sequence, Sequence == Source.Element, Cell : UIKit.UICollectionViewCell, Source : OndatoSDK.ObservableType
  public func items<DataSource, Source>(dataSource: DataSource) -> (_ source: Source) -> any OndatoSDK.Disposable where DataSource : OndatoSDK.RxCollectionViewDataSourceType, DataSource : UIKit.UICollectionViewDataSource, Source : OndatoSDK.ObservableType, DataSource.Element == Source.Element
}
extension OndatoSDK.Reactive where Base : UIKit.UICollectionView {
  public typealias DisplayCollectionViewCellEvent = (cell: UIKit.UICollectionViewCell, at: Foundation.IndexPath)
  public typealias DisplayCollectionViewSupplementaryViewEvent = (supplementaryView: UIKit.UICollectionReusableView, elementKind: Swift.String, at: Foundation.IndexPath)
  public var dataSource: OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSource> {
    get
  }
  public func setDataSource(_ dataSource: any UIKit.UICollectionViewDataSource) -> any OndatoSDK.Disposable
  public var itemSelected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemDeselected: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemHighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var itemUnhighlighted: OndatoSDK.ControlEvent<Foundation.IndexPath> {
    get
  }
  public var willDisplayCell: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewCellEvent> {
    get
  }
  public var willDisplaySupplementaryView: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewSupplementaryViewEvent> {
    get
  }
  public var didEndDisplayingCell: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewCellEvent> {
    get
  }
  public var didEndDisplayingSupplementaryView: OndatoSDK.ControlEvent<OndatoSDK.Reactive<Base>.DisplayCollectionViewSupplementaryViewEvent> {
    get
  }
  public func modelSelected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func modelDeselected<T>(_ modelType: T.Type) -> OndatoSDK.ControlEvent<T>
  public func model<T>(at indexPath: Foundation.IndexPath) throws -> T
}
@available(iOS 10.0, tvOS 10.0, *)
extension OndatoSDK.Reactive where Base : UIKit.UICollectionView {
  public var prefetchDataSource: OndatoSDK.DelegateProxy<UIKit.UICollectionView, any UIKit.UICollectionViewDataSourcePrefetching> {
    get
  }
  public func setPrefetchDataSource(_ prefetchDataSource: any UIKit.UICollectionViewDataSourcePrefetching) -> any OndatoSDK.Disposable
  public var prefetchItems: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
  public var cancelPrefetchingForItems: OndatoSDK.ControlEvent<[Foundation.IndexPath]> {
    get
  }
}
public struct AnimationKeypath {
  public init(keypath: Swift.String)
  public init(keys: [Swift.String])
}
extension OndatoSDK.Reactive where Base : UIKit.UIDatePicker {
  public var date: OndatoSDK.ControlProperty<Foundation.Date> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Foundation.Date> {
    get
  }
  public var countDownDuration: OndatoSDK.ControlProperty<Foundation.TimeInterval> {
    get
  }
}
final public class ColorValueProvider : OndatoSDK.AnyValueProvider {
  public init(block: @escaping OndatoSDK.ColorValueProvider.ColorValueBlock)
  public init(_ color: OndatoSDK.Color)
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> OndatoSDK.Color
  final public var color: OndatoSDK.Color {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.SingleTrait {
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Self.Element {
    get async throws
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.PrimitiveSequenceType where Self.Trait == OndatoSDK.MaybeTrait {
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Self.Element? {
    get async throws
  }
  #endif
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension OndatoSDK.PrimitiveSequenceType where Self.Element == Swift.Never, Self.Trait == OndatoSDK.CompletableTrait {
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Swift.Void {
    get async throws
  }
  #endif
}
@_inheritsConvenienceInitializers final public class AsyncSubject<Element> : OndatoSDK.Observable<Element>, OndatoSDK.SubjectType, OndatoSDK.ObserverType {
  public typealias SubjectObserverType = OndatoSDK.AsyncSubject<Element>
  final public var hasObservers: Swift.Bool {
    get
  }
  public init()
  final public func on(_ event: OndatoSDK.Event<Element>)
  override final public func subscribe<Observer>(_ observer: Observer) -> any OndatoSDK.Disposable where Element == Observer.Element, Observer : OndatoSDK.ObserverType
  final public func asObserver() -> OndatoSDK.AsyncSubject<Element>
  public typealias Observer = OndatoSDK.AsyncSubject<Element>
  @objc deinit
}
extension OndatoSDK.Reactive where Base : UIKit.UITextField {
  public var text: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var value: OndatoSDK.ControlProperty<Swift.String?> {
    get
  }
  public var attributedText: OndatoSDK.ControlProperty<Foundation.NSAttributedString?> {
    get
  }
}
extension OndatoSDK.ObservableType {
  public func startWith(_ elements: Self.Element...) -> OndatoSDK.Observable<Self.Element>
}
public enum ScanningImage {
  case cgImage(CoreGraphics.CGImage)
  case pixelBuffer(CoreVideo.CVPixelBuffer)
}
extension OndatoSDK.CompletableEvent : Swift.Sendable {}
extension OndatoSDK.OndatoServiceError.OndatoServiceErrorType : Swift.Equatable {}
extension OndatoSDK.OndatoServiceError.OndatoServiceErrorType : Swift.Hashable {}
extension OndatoSDK.OndatoServiceError.OndatoServiceErrorType : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.CertificateType : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.CertificateType : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.CertificateItem : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.CertificateItem : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.CertificateItem : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.DataGroupId : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.DataGroupId : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.DataGroupId : Swift.RawRepresentable {}
extension OndatoSDK.LayerType : Swift.Equatable {}
extension OndatoSDK.LayerType : Swift.Hashable {}
extension OndatoSDK.LayerType : Swift.RawRepresentable {}
extension OndatoSDK.MatteType : Swift.Equatable {}
extension OndatoSDK.MatteType : Swift.Hashable {}
extension OndatoSDK.MatteType : Swift.RawRepresentable {}
extension OndatoSDK.BlendMode : Swift.Equatable {}
extension OndatoSDK.BlendMode : Swift.Hashable {}
extension OndatoSDK.BlendMode : Swift.RawRepresentable {}
extension OndatoSDK.PassportAuthenticationStatus : Swift.Equatable {}
extension OndatoSDK.PassportAuthenticationStatus : Swift.Hashable {}
extension OndatoSDK.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension OndatoSDK.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension OndatoSDK.SubjectLifetimeScope : Swift.Equatable {}
extension OndatoSDK.SubjectLifetimeScope : Swift.Hashable {}
extension OndatoSDK.LottieBackgroundBehavior : Swift.Equatable {}
extension OndatoSDK.LottieBackgroundBehavior : Swift.Hashable {}
extension OndatoSDK.CoordinateSpace : Swift.Equatable {}
extension OndatoSDK.CoordinateSpace : Swift.Hashable {}
extension OndatoSDK.CoordinateSpace : Swift.RawRepresentable {}
extension OndatoSDK.RxCocoaInterceptionMechanism : Swift.Equatable {}
extension OndatoSDK.RxCocoaInterceptionMechanism : Swift.Hashable {}
extension OndatoSDK.OndatoSupportedLanguage : Swift.Equatable {}
extension OndatoSDK.OndatoSupportedLanguage : Swift.Hashable {}
extension OndatoSDK.ColorFormatDenominator : Swift.Equatable {}
extension OndatoSDK.ColorFormatDenominator : Swift.Hashable {}
extension OndatoSDK.MRZFormat : Swift.Equatable {}
extension OndatoSDK.MRZFormat : Swift.Hashable {}
extension OndatoSDK.MRZResult.DocumentType : Swift.Equatable {}
extension OndatoSDK.MRZResult.DocumentType : Swift.Hashable {}
extension OndatoSDK.MRZResult.Sex : Swift.Equatable {}
extension OndatoSDK.MRZResult.Sex : Swift.Hashable {}
extension OndatoSDK.LogLevel : Swift.Equatable {}
extension OndatoSDK.LogLevel : Swift.Hashable {}
extension OndatoSDK.LogLevel : Swift.RawRepresentable {}
extension OndatoSDK.TakeBehavior : Swift.Equatable {}
extension OndatoSDK.TakeBehavior : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.DocTypeEnum : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.DocTypeEnum : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension OndatoSDK.DocTypeEnum : Swift.RawRepresentable {}
extension OndatoSDK.SecureMessagingSupportedAlgorithms : Swift.Equatable {}
extension OndatoSDK.SecureMessagingSupportedAlgorithms : Swift.Hashable {}
extension OndatoSDK.OndatoEnvironment : Swift.Equatable {}
extension OndatoSDK.OndatoEnvironment : Swift.Hashable {}
extension OndatoSDK.OndatoEnvironment : Swift.RawRepresentable {}
extension OndatoSDK.PACEMappingType : Swift.Equatable {}
extension OndatoSDK.PACEMappingType : Swift.Hashable {}
extension OndatoSDK.VirtualTimeComparison : Swift.Equatable {}
extension OndatoSDK.VirtualTimeComparison : Swift.Hashable {}
extension OndatoSDK.RecognitionLevel : Swift.Equatable {}
extension OndatoSDK.RecognitionLevel : Swift.Hashable {}
extension OndatoSDK.OndatoDocumentType : Swift.Equatable {}
extension OndatoSDK.OndatoDocumentType : Swift.Hashable {}
extension OndatoSDK.OndatoDocumentType : Swift.RawRepresentable {}
